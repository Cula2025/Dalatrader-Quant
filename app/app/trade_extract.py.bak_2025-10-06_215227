from __future__ import annotations
from typing import Any, Mapping, Sequence
import pandas as pd

import pandas as pd

def _normalize_trades_df(df):
    """
    Säkerställ att trades-DataFrame har:
      - kolumn 'date' (skapa från index/'timestamp'/'time' om saknas)
      - numeriska 'price','qty','value' (beräkna 'value' vid behov)
      - sorterad på 'date' och 'date' som DatetimeIndex
    """
    if df is None:
        return pd.DataFrame()
    if not hasattr(df, "copy"):
        return pd.DataFrame()
    df = df.copy()

    # lower-case kolumnnamn
    try:
        df.rename(columns={c: str(c).lower() for c in df.columns}, inplace=True)
    except Exception:
        pass

    # skapa 'date' om saknas
    if 'date' not in df.columns:
        if isinstance(df.index, pd.DatetimeIndex):
            df['date'] = df.index
        elif 'timestamp' in df.columns:
            df['date'] = pd.to_datetime(df['timestamp'], errors='coerce', utc=False)
        elif 'time' in df.columns:
            df['date'] = pd.to_datetime(df['time'], errors='coerce', utc=False)

    # konvertera till datetime & städa
    if 'date' in df.columns:
        df['date'] = pd.to_datetime(df['date'], errors='coerce', utc=False)
        df = df.dropna(subset=['date']).sort_values('date')
        try:
            df = df.set_index('date')
        except Exception:
            pass

    # numerik
    for c in ('price','qty','value'):
        if c in df.columns:
            df[c] = pd.to_numeric(df[c], errors='coerce')

    # räkna value om saknas
    if 'value' not in df.columns and 'price' in df.columns and 'qty' in df.columns:
        df['value'] = df['price'] * df['qty']

    return df

CANON = ["date","side","price","qty","value","ticker","profile","cash","equity","pnl"]

def _to_df(obj: Any) -> pd.DataFrame:
    if obj is None:
        return pd.DataFrame(columns=CANON)

    if isinstance(obj, pd.DataFrame):
        df = obj.copy()
    elif isinstance(obj, (list, tuple)):
        df = pd.DataFrame(obj)
    elif isinstance(obj, Mapping):
        if "trades" in obj:
            return _to_df(obj["trades"])
        df = pd.DataFrame(obj)
    else:
        return pd.DataFrame(columns=CANON)

    # lower-case columns for easier matching
    df.columns = [str(c).strip().lower() for c in df.columns]

    # prefer explicit date column
    if "date" not in df.columns:
        for c in ("timestamp","datetime","time","day"):
            if c in df.columns:
                df["date"] = df.pop(c)
                break

    # ensure DatetimeIndex
    if "date" in df.columns:
        df["date"] = pd.to_datetime(df["date"], errors="coerce")
        df = df.dropna(subset=["date"]).set_index("date")
    elif not isinstance(df.index, pd.DatetimeIndex):
        idx = pd.to_datetime(df.index, errors="coerce")
        df.index = idx
        df = df.dropna()
        if not isinstance(df.index, pd.DatetimeIndex):
            # still no, fallback minimal
            df["date"] = pd.Timestamp("1970-01-01")
            df = df.set_index("date")

    # normalize column names/aliases → canon
    colmap = {
        "action":"side","signal":"side","type":"side",
        "quantity":"qty","shares":"qty","amount":"value","value":"value",
        "symbol":"ticker","instrument":"ticker",
    }
    for src, dst in colmap.items():
        if src in df.columns and dst not in df.columns:
            df[dst] = df.pop(src)

    # make sure all columns exist
    for c in CANON:
        if c != "date" and c not in df.columns:
            df[c] = None

    # compute value if possible
    if df["value"].isna().all():
        try:
            price = pd.to_numeric(df["price"], errors="coerce")
            qty   = pd.to_numeric(df["qty"], errors="coerce")
            df["value"] = price * qty
        except Exception:
            pass

    df = df.sort_index()
    # make index tz-naive for Streamlit/Altair
    if getattr(df.index, "tz", None) is not None:
        df.index = df.index.tz_localize(None)
    return df[[c for c in CANON if c in df.columns]]

def to_trades_df(x: Any) -> pd.DataFrame:
    """Public helper: normalize any trades payload to a clean DataFrame with DatetimeIndex."""
    return _to_df(x)
