from __future__ import annotations

import re

from app.btwrap import run_backtest as _RUNBT
from app.portfolio_signals import _import_backtest
# --- profile pre-apply (inject early) ---
try:
    from app.profile_apply import pre_apply as _prof_pre_apply
    _prof_pre_apply()
except Exception as _e:
    print("[profile] pre_apply failed:", type(_e).__name__, _e)
# --- /profile pre-apply ---


# --- DF VALIDATION & SAFE RUN_BT ---
import pandas as pd
import streamlit as st
# === PRE-APPLY PENDING PROFILE (m√•ste k√∂ras innan n√•gra widgets skapas) ===
if "_pending_profile" in st.session_state:
    _pp = st.session_state.pop("_pending_profile") or {}
    # Ticker
    t = (_pp.get("ticker") or "").strip()
    if t:
        st.session_state["ticker"] = t
    # Params -> session_state
    params = _pp.get("params") or {}
    _keymap = {
        "use_rsi_filter":"use_rsi_filter","rsi_window":"rsi_window","rsi_min":"rsi_min","rsi_max":"rsi_max",
        "use_trend_filter":"use_trend_filter","trend_ma_type":"trend_ma_type","trend_ma_window":"trend_ma_window",
        "breakout_lookback":"breakout_lookback","exit_lookback":"exit_lookback",
        "use_macd_filter":"use_macd_filter","macd_fast":"macd_fast","macd_slow":"macd_slow","macd_signal":"macd_signal",
        "use_bb_filter":"use_bb_filter","bb_window":"bb_window","bb_nstd":"bb_nstd","bb_min":"bb_min",
        "use_stop_loss":"use_stop_loss","stop_mode":"stop_mode","stop_loss_pct":"stop_loss_pct",
        "atr_window":"atr_window","atr_mult":"atr_mult","use_atr_trailing":"use_atr_trailing","atr_trail_mult":"atr_trail_mult",
    }
    for s, d in _keymap.items():
        if s in params:
            st.session_state[d] = params[s]
    # Datum
    fd = _pp.get("from_date") or _pp.get("start") or ""
    td = _pp.get("to_date")   or _pp.get("end")   or ""
    if fd: st.session_state["from_date"] = str(fd)
    if td: st.session_state["to_date"]   = str(td)
    # Efter att vi matat in state, g√∂r en rerun s√• widgets f√•r nya default
    st.rerun()
# === /PRE-APPLY ===

from app.dfguard import to_dataframe as _to_df

# --- normalize ohlcv (idempotent) ---
def _normalize_ohlcv(df):
    import pandas as pd
    # Tomt ‚Üí tom DF
    if df is None:
        return pd.DataFrame()
    # G√∂r om till DataFrame om m√∂jligt
    if not isinstance(df, pd.DataFrame):
        try:
            df = pd.DataFrame(df)
        except Exception:
            return pd.DataFrame()

    # S√§kerst√§ll str-kolumnnamn och trim
    cols = {}
    for c in df.columns:
        cols[c] = str(c).strip()
    if cols:
        df = df.rename(columns=cols)

    # lowercase alla kolumner
    lc = {c: c.lower() for c in df.columns}
    df = df.rename(columns=lc)

    # alias ‚Üí standardnamn
    aliases = {
        "open": ["open","o","op","open_price"],
        "high": ["high","h","hi","high_price"],
        "low":  ["low","l","lo","low_price"],
        "close":["close","c","cl","adjclose","adj_close","price","last"],
        "volume":["volume","v","vol","turnover"],
        "date":["date","time","timestamp"],
    }
    m = {}
    for std, cands in aliases.items():
        for a in cands:
            if a in df.columns:
                m[a] = std
                break
    if m:
        df = df.rename(columns=m)

    # G√∂r TitleCase f√∂r OHLCV
    df = df.rename(columns={
        "open":"Open","high":"High","low":"Low","close":"Close","volume":"Volume","date":"Date"
    })

    # S√§tt datetime-index om Date finns
    if "Date" in df.columns:
        try:
            df["Date"] = pd.to_datetime(df["Date"])
            df = df.set_index("Date")
        except Exception:
            pass

    # Sortera p√• index om det √§r datum
    try:
        if hasattr(df.index, "inferred_type") and "date" in str(df.index.inferred_type).lower():
            df = df.sort_index()
    except Exception:
        pass

    # Plocka bara de n√∂dv√§ndiga kolumnerna om de finns
    cols_need = [c for c in ["Open","High","Low","Close","Volume"] if c in df.columns]
    if cols_need:
        df = df[cols_need + [c for c in df.columns if c not in cols_need]]

    return df

# --- end normalize ohlcv ---

# --- Force GET_OHLCV result -> DataFrame ---
def _fetch_df_for_backtest(ticker, start, end):
    raw = _fetch_df_for_backtest(ticker, start, end)
    try:
        df = _to_df(raw)
    except Exception as e:
        st.error(f"DF-konvertering misslyckades: {e}")
        raise
    return df


def _normalize_ohlcv_df(obj):
    # Till DataFrame
    if isinstance(obj, tuple) and len(obj) > 0:
        obj = obj[0]
    if isinstance(obj, dict):
        if 'df' in obj: obj = obj['df']
        elif 'data' in obj: obj = obj['data']
    if not isinstance(obj, pd.DataFrame):
        try:
            obj = pd.DataFrame(obj)
        except Exception as e:
            raise TypeError(f"F√∂rv√§ntade en DataFrame, fick {type(obj).__name__}: {e}")
    if obj is None or obj.empty:
        raise ValueError("DataFrame √§r tom (ingen kursdata).")

    # Kolumnnamn -> Open/High/Low/Close/Volume
    lower = {c.lower(): c for c in obj.columns}
    rename = {}
    for w in ("open","high","low","close","volume"):
        if w in lower:
            rename[lower[w]] = w.capitalize()
    if rename:
        obj = obj.rename(columns=rename)

    missing = [c for c in ("Open","High","Low","Close") if c not in obj.columns]
    if missing:
        raise ValueError(f"Saknar kolumner: {missing}. Hittade: {list(obj.columns)}")

    # Datumindex
    if not isinstance(obj.index, pd.DatetimeIndex):
        date_col = None
        for cand in ("date","Date","time","Time"):
            if cand in obj.columns:
                date_col = cand; break
        if date_col:
            obj[date_col] = pd.to_datetime(obj[date_col])
            obj = obj.set_index(date_col)
        else:
            obj.index = pd.to_datetime(obj.index)

    obj = obj.sort_index()
    return obj

def _RUN_BT_SAFE(df_like, params):
    try:
        df = _normalize_ohlcv_df(df_like)
    except Exception as e:
        # Visa tydligt fel i UI OCH re-raise s√• "Backtest misslyckades: ..." f√•ngar det
        st.error(f"F√∂rbehandling av data misslyckades: {e}")
        raise
    return _RUN_BT_SAFE(df, params)
# --- END DF VALIDATION & SAFE RUN_BT ---
RUN_BT, Params = _import_backtest()

# -*- coding: utf-8 -*-
"""
Backtest (ren sida)
- Laddar/projicerar profiler fr√•n outputs/opt_results/*.json
- Fyller UI-parametrar
- K√∂r backtest mot vald ticker och datum
- Sparar "TICKER_tmp.json" (singelprofil) vid behov
"""
from app.btwrap import run_backtest as _run_backtest

import json
import math
import datetime as dt
from pathlib import Path
from typing import Any, Dict, List

import numpy as np
import pandas as pd
import streamlit as st

# Din appkod
try:
    from app.portfolio_signals import _import_backtest, _maybe_build_params, buyhold_equity_from_price  # type: ignore
except Exception:  # skydd om modulnamn skiljer sig
    _import_backtest = None
    _maybe_build_params = None
    buyhold_equity_from_price = None
try:
    from app.data_providers import get_ohlcv as GET_OHLCV  # type: ignore

except Exception:
    GET_OHLCV = None  # endast om du vill h√§mta prisdata lokalt

PROFILES_DIR = (Path("outputs") / "opt_results").resolve()


# ---------- Hj√§lpare f√∂r profiler ----------

def _normalize_ticker(t: str) -> str:
    t = (t or "").strip().upper().replace("_", "-").replace(" ", "-")
    return t if t.endswith(".ST") else (t + ".ST")


def _read_profiles_file(fp: Path) -> List[Dict[str, Any]]:
    data = json.loads(fp.read_text(encoding="utf-8"))
    if isinstance(data, dict) and "profiles" in data and isinstance(data["profiles"], list):
        src = data["profiles"]
    else:
        # single profil-format
        src = [data]
    out: List[Dict[str, Any]] = []
    for p in src:
        if not isinstance(p, dict):
            continue
        name = p.get("name") or p.get("profile") or fp.stem
        ticker = _normalize_ticker(p.get("ticker") or "")
        params = p.get("params") or {}
        metrics = p.get("metrics") or {}
        out.append({"name": name, "ticker": ticker, "params": params, "metrics": metrics})
    return out


def _apply_profile_to_state(profile: Dict[str, Any]) -> None:
    """Skriv profilens v√§rden till session_state s√• formul√§ret fylls."""
    if not profile:
        return
    t = (profile.get("ticker") or "").strip()
    if t:
        st.session_state["ticker"] = _normalize_ticker(t)

    params = profile.get("params") or {}
    for k, v in params.items():
        st.session_state[k] = v


# ---------- UI-defaults ----------

DEFAULTS: Dict[str, Any] = {
    "ticker": "VOLV B",
    "from_date": (dt.date.today().replace(year=dt.date.today().year - 5)).isoformat(),
    "to_date": dt.date.today().isoformat(),
    # Trend/EMA
    "use_trend_filter": False,
    "trend_ma_window": 100,
    # RSI
    "rsi_window": 8,
    "rsi_min": 30.0,
    "rsi_max": 70.0,
    # Breakouts
    "breakout_lookback": 55,
    "exit_lookback": 20,
    # MACD
    "use_macd_filter": False,
    "macd_fast": 12,
    "macd_slow": 26,
    "macd_signal": 9,
    # Bollinger
    "use_bb_filter": False,
    "bb_window": 20,
    "bb_nstd": 2.0,
    "bb_min": 0.0,
    # Stops
    "use_stop_loss": False,
    "stop_mode": "pct",           # "pct" eller "atr"
    "stop_loss_pct": 0.08,        # 8%
    "atr_window": 14,
    "atr_mult": 2.0,
    "use_atr_trailing": False,
    "atr_trail_mult": 1.5,
}

for k, v in DEFAULTS.items():
    st.session_state.setdefault(k, v)
# LEGACY_UI # 
# LEGACY_UI # 
# LEGACY_UI # # ---------- Sidopanel: v√§lj & applicera profil ----------
# LEGACY_UI # 
# LEGACY_UI # st.sidebar.header("Profiler")
# LEGACY_UI # st.sidebar.caption(f"Katalog: `{PROFILES_DIR}`")
# LEGACY_UI # 
# LEGACY_UI # files = sorted([fp for fp in PROFILES_DIR.glob("*.json") if fp.is_file()])
# LEGACY_UI # if files:
# LEGACY_UI #     file_idx = st.sidebar.selectbox(
# LEGACY_UI #         "V√§lj optimeringsfil (.json)",
# LEGACY_UI #         options=list(range(len(files))),
# LEGACY_UI #         format_func=lambda i: files[i].name,
# LEGACY_UI #         key="back_file_idx",
# LEGACY_UI #     )
# LEGACY_UI #     fp = files[file_idx]
# LEGACY_UI #     try:
# LEGACY_UI #         profiles = _read_profiles_file(fp)
# LEGACY_UI #     except Exception as e:
# LEGACY_UI #         profiles = []
# LEGACY_UI #         st.sidebar.error(f"Kunde inte l√§sa profiler: {e}")
# LEGACY_UI # 
# LEGACY_UI #     if profiles:
# LEGACY_UI #         prof_idx = st.sidebar.selectbox(
# LEGACY_UI #             "V√§lj profil i filen",
# LEGACY_UI #             options=list(range(len(profiles))),
# LEGACY_UI #             format_func=lambda i: f"{profiles[i]['ticker'] or ''} ‚Äì {profiles[i]['name']}",
# LEGACY_UI #             key="back_prof_idx",
# LEGACY_UI #         )
# LEGACY_UI #         if st.sidebar.button("Anv√§nd vald profil", type="primary", width='stretch'):
# LEGACY_UI #             _apply_profile_to_state(profiles[prof_idx])
# LEGACY_UI #             st.sidebar.success("Profil applicerad till parametrarna.")
# LEGACY_UI # else:
# LEGACY_UI #     st.sidebar.info("Inga *.json-filer hittades i katalogen.")
# LEGACY_UI # 
# LEGACY_UI # 
# LEGACY_UI # # ---------- Huvud: formul√§r ----------
# LEGACY_UI # 
# LEGACY_UI # st.title("Backtest")
# LEGACY_UI # st.session_state.setdefault("trend_ma_window", 200)
# LEGACY_UI # 
# LEGACY_UI # with st.expander("Parametrar", expanded=True):
# LEGACY_UI #     colA, colB = st.columns(2)
# LEGACY_UI # 
# LEGACY_UI #     with colA:
# LEGACY_UI #         st.text_input("Ticker", key="ticker")
# LEGACY_UI #         st.text_input("Fr√•n (YYYY-MM-DD)", key="from_date")
# LEGACY_UI #         st.text_input("Till (YYYY-MM-DD)", key="to_date")
# LEGACY_UI # 
# LEGACY_UI #         st.checkbox("EMA trend-gate", key="use_trend_filter")
# LEGACY_UI #         st.number_input("EMA-f√∂nster", min_value=1, value=int(st.session_state.get("trend_ma_window", 100)), step=1, key="trend_ma_window")
# LEGACY_UI # 
# LEGACY_UI #         st.number_input("RSI-f√∂nster", min_value=1, value=int(st.session_state.get("rsi_window", 8)), step=1, key="rsi_window")
# LEGACY_UI #         st.number_input("RSI min (k√∂p-kors upp)", value=float(st.session_state.get("rsi_min", 30.0)), step=1.0, key="rsi_min")
# LEGACY_UI #         st.number_input("RSI max (s√§lj-kors ned)", value=float(st.session_state.get("rsi_max", 70.0)), step=1.0, key="rsi_max")
# LEGACY_UI # 
# LEGACY_UI #         st.number_input("Breakout lookback (0=av)", min_value=0, value=int(st.session_state.get("breakout_lookback", 55)), step=1, key="breakout_lookback")
# LEGACY_UI #         st.number_input("Exit lookback (0=av)", min_value=0, value=int(st.session_state.get("exit_lookback", 20)), step=1, key="exit_lookback")
# LEGACY_UI # 
# LEGACY_UI #     with colB:
# LEGACY_UI #         st.checkbox("MACD-filter (histogram > 0)", key="use_macd_filter")
# LEGACY_UI #         st.number_input("MACD fast", min_value=1, value=int(st.session_state.get("macd_fast", 12)), step=1, key="macd_fast")
# LEGACY_UI #         st.number_input("MACD slow", min_value=1, value=int(st.session_state.get("macd_slow", 26)), step=1, key="macd_slow")
# LEGACY_UI #         st.number_input("MACD signal", min_value=1, value=int(st.session_state.get("macd_signal", 9)), step=1, key="macd_signal")
# LEGACY_UI # 
# LEGACY_UI #         st.checkbox("Bollinger %B-filter", key="use_bb_filter")
# LEGACY_UI #         st.number_input("BB f√∂nster", min_value=1, value=int(st.session_state.get("bb_window", 20)), step=1, key="bb_window")
# LEGACY_UI #         st.number_input("BB std", min_value=0.1, value=float(st.session_state.get("bb_nstd", 2.0)), step=0.1, key="bb_nstd")
# LEGACY_UI #         st.number_input("BB min (k√∂p-kors upp)", min_value=0.0, value=float(st.session_state.get("bb_min", 0.0)), step=0.05, key="bb_min")
# LEGACY_UI # 
# LEGACY_UI #         st.checkbox("Stop-loss", key="use_stop_loss")
# LEGACY_UI #         st.selectbox("Stop-typ", options=["pct", "atr"], key="stop_mode")
# LEGACY_UI #         st.number_input("Stop-loss % (om pct)", min_value=0.001, value=float(st.session_state.get("stop_loss_pct", 0.08)), step=0.005, key="stop_loss_pct")
# LEGACY_UI #         st.number_input("ATR f√∂nster", min_value=1, value=int(st.session_state.get("atr_window", 14)), step=1, key="atr_window")
# LEGACY_UI #         st.number_input("ATR multipel", min_value=0.1, value=float(st.session_state.get("atr_mult", 2.0)), step=0.1, key="atr_mult")
# LEGACY_UI #         st.checkbox("ATR trailing", key="use_atr_trailing")
# LEGACY_UI #         st.number_input("ATR trailing multipel", min_value=0.1, value=float(st.session_state.get("atr_trail_mult", 1.5)), step=0.1, key="atr_trail_mult")
# LEGACY_UI # 
# LEGACY_UI # 
# LEGACY_UI # # ---------- K√∂r backtest ----------
# LEGACY_UI # 
# LEGACY_UI # def _collect_params_from_state() -> Dict[str, Any]:
# LEGACY_UI #     p = {}
# LEGACY_UI #     for k in DEFAULTS.keys():
# LEGACY_UI #         p[k] = st.session_state.get(k, DEFAULTS[k])
# LEGACY_UI #     return p
# LEGACY_UI # 
# LEGACY_UI # 
# LEGACY_UI # def _coerce_date(s: str) -> dt.date:
# LEGACY_UI #     try:
# LEGACY_UI #         return dt.date.fromisoformat(str(s))
# LEGACY_UI #     except Exception:
# LEGACY_UI #         return dt.date(2020, 1, 1)
# LEGACY_UI # 
# LEGACY_UI # 
# LEGACY_UI # def _try_run_backtest(ticker: str, params: Dict[str, Any], start: dt.date, end: dt.date) -> Dict[str, Any]:
# LEGACY_UI #     """Anropa din backtest-funktion, men var tolerant med signaturer."""
# LEGACY_UI #     # f√∂rs√∂k #1
# LEGACY_UI #     if _import_backtest is None:
# LEGACY_UI #         raise RuntimeError("Backtest-funktion (_import_backtest) kunde inte importeras.")
# LEGACY_UI # 
# LEGACY_UI #     try:
# LEGACY_UI #         res = _run_backtest(
# LEGACY_UI #             ticker=ticker, params=params,
# LEGACY_UI #             start=start, end=end
# LEGACY_UI #         )
# LEGACY_UI #         return res
# LEGACY_UI #     except TypeError:
# LEGACY_UI #         # f√∂rs√∂k #2 ‚Äì annan ordning/namn
# LEGACY_UI #         try:
# LEGACY_UI #             res = _run_backtest(ticker, params, start, end)  # type: ignore
# LEGACY_UI #             return res
# LEGACY_UI #         except Exception as e2:
# LEGACY_UI #             raise
# LEGACY_UI # 
# LEGACY_UI # @st.cache_data(show_spinner=False)
# LEGACY_UI # def _simple_metrics_from_equity(equity: pd.Series) -> Dict[str, float]:
# LEGACY_UI #     # grova nyckeltal om pipeline inte returnerar metrics
# LEGACY_UI #     eq = equity.dropna().astype(float)
# LEGACY_UI #     if len(eq) < 2:
# LEGACY_UI #         return {}
# LEGACY_UI #     total = float(eq.iloc[-1] / eq.iloc[0])
# LEGACY_UI #     ret = np.log(eq).diff().dropna()
# LEGACY_UI #     cagr = (total ** (252.0 / max(1, len(eq)))) - 1.0  # antag dagliga data
# LEGACY_UI #     dd = (eq / eq.cummax() - 1.0).min()
# LEGACY_UI #     sharpe_d = (ret.mean() / (ret.std() + 1e-9)) * np.sqrt(252.0)
# LEGACY_UI #     return {"TotalReturn": total, "CAGR": cagr, "SharpeD": sharpe_d, "MaxDD": dd}
# LEGACY_UI # 
# LEGACY_UI # col_run, col_save = st.columns([1,1])
# LEGACY_UI # if col_run.button("K√∂r backtest", type="primary", width='stretch'):
# LEGACY_UI #     ticker = _normalize_ticker(st.session_state.get("ticker", ""))
# LEGACY_UI #     params = _collect_params_from_state()
# LEGACY_UI #     start = _coerce_date(st.session_state.get("from_date", DEFAULTS["from_date"]))
# LEGACY_UI #     end = _coerce_date(st.session_state.get("to_date", DEFAULTS["to_date"]))
# LEGACY_UI # 
# LEGACY_UI #     try:
# LEGACY_UI #         res = _try_run_backtest(ticker, params, start, end)
# LEGACY_UI #         # F√∂rs√∂k hitta metrics
# LEGACY_UI #         metrics = {}
# LEGACY_UI #         if isinstance(res, dict):
# LEGACY_UI #             metrics = res.get("metrics") or res.get("summary") or {}
# LEGACY_UI #             # equity-kurva?
# LEGACY_UI #             eq = res.get("equity")
# LEGACY_UI #             if (not metrics) and isinstance(eq, (pd.Series, list)):
# LEGACY_UI #                 if isinstance(eq, list):
# LEGACY_UI #                     eq = pd.Series(eq)
# LEGACY_UI #                 metrics = _simple_metrics_from_equity(eq)
# LEGACY_UI #         st.session_state["_last_metrics"] = metrics or {}
# LEGACY_UI #         st.success("Backtest klart.")
# LEGACY_UI #     except Exception as e:
# LEGACY_UI #         st.error(f"Backtest misslyckades: {e}")

# Visa metrics om vi har dem
m = st.session_state.get("_last_metrics") or {}
if m:
    c1, c2, c3, c4, c5 = st.columns(5)
    c1.metric("TotalReturn", f"{m.get('TotalReturn', 0):.3f}√ó")
    c2.metric("CAGR", f"{m.get('CAGR', 0):.3f}")
    c3.metric("SharpeD", f"{m.get('SharpeD', 0):.3f}")
    c4.metric("MaxDD", f"{m.get('MaxDD', 0):.3f}")
    c5.metric("Buy&Hold", f"{m.get('BuyHold', m.get('Buy&Hold', float('nan'))):.3f}" if not math.isnan(float(m.get('BuyHold', m.get('Buy&Hold', float('nan'))))) else "‚Äì")

# ---------- Spara som TMP ----------

def _current_params_payload() -> Dict[str, Any]:
    params = _collect_params_from_state()
    return {
        "profiles": [
            {
                "name": st.text_input("Profilnamn att spara", value="TMP fr√•n UI", key="tmp_profile_name"),
                "ticker": _normalize_ticker(st.session_state.get("ticker", "")),
                "params": params,
                "metrics": st.session_state.get("_last_metrics", {}),
            }
        ]
    }

payload = _current_params_payload()
if col_save.button("Spara som TMP", width='stretch'):
    try:
        t = payload["profiles"][0]["ticker"]
        base = t.replace(".ST", "").replace(" ", "_")
        dst = PROFILES_DIR / f"{base}_tmp.json"
        dst.write_text(json.dumps(payload, indent=2, ensure_ascii=False), encoding="utf-8")
        st.success(f"Sparade: {dst}")
    except Exception as e:
        st.error(f"Kunde inte spara: {e}")


# -- Inject profile loader (safe tail) --
try:
    from app.profile_loader import render_profiles_sidebar as _bt_profiles
    _bt_profiles()
except Exception as _e:
    # Tyst i UI:t; kolla loggar vid behov
    pass
# -- /Inject profile loader --

# ======== Ladda profil (ren, fungerande) ========
import json, os
import streamlit as st
from pathlib import Path

def _apply_profile_to_session(sel: dict):
    # ticker
    t = (sel.get("ticker") or "").strip()
    if t:
        st.session_state["ticker"] = t

    # params -> session keys
    params = sel.get("params") or {}
    keymap = {
        # RSI
        "use_rsi_filter": "use_rsi_filter",
        "rsi_window": "rsi_window",
        "rsi_min": "rsi_min",
        "rsi_max": "rsi_max",

        # Trend (EMA/MA)
        "use_trend_filter": "use_trend_filter",
        "trend_ma_type": "trend_ma_type",
        "trend_ma_window": "trend_ma_window",

        # Donchian
        "breakout_lookback": "breakout_lookback",
        "exit_lookback": "exit_lookback",

        # MACD
        "use_macd_filter": "use_macd_filter",
        "macd_fast": "macd_fast",
        "macd_slow": "macd_slow",
        "macd_signal": "macd_signal",

        # Bollinger %B
        "use_bb_filter": "use_bb_filter",
        "bb_window": "bb_window",
        "bb_nstd": "bb_nstd",
        "bb_min": "bb_min",

        # Stops/ATR
        "use_stop_loss": "use_stop_loss",
        "stop_mode": "stop_mode",
        "stop_loss_pct": "stop_loss_pct",
        "atr_window": "atr_window",
        "atr_mult": "atr_mult",
        "use_atr_trailing": "use_atr_trailing",
        "atr_trail_mult": "atr_trail_mult",
    }
    for src, dst in keymap.items():
        if src in params:
            st.session_state[dst] = params[src]

    # dates (5 √•r tillbaka fr√•n nu brukar din app defaulta, men om profilen har med, applicera)
    from_date = sel.get("from_date") or sel.get("start") or ""
    to_date   = sel.get("to_date")   or sel.get("end")   or ""
    if from_date:
        st.session_state["from_date"] = str(from_date)
    if to_date:
        st.session_state["to_date"] = str(to_date)

# Sidebar UI (ren)
with st.sidebar.expander("üìÇ Ladda profil", expanded=True):
    prof_dir = Path("/srv/trader/app/profiles")
    files = sorted([p for p in prof_dir.glob("*.json") if p.is_file()], key=lambda p: p.name)

    if not files:
        st.info("Inga profiler hittades i /srv/trader/app/profiles.")
    else:
        fnames = [f.name for f in files]
        f_idx = st.selectbox("Profilfil", options=list(range(len(fnames))), format_func=lambda i: fnames[i], key="bf_prof_file_idx")
        sel_file = files[f_idx]

        try:
            data = json.loads(sel_file.read_text(encoding="utf-8"))
        except Exception as e:
            st.error(f"Kunde inte l√§sa JSON: {type(e).__name__}: {e}")
            data = {}

        profiles = data.get("profiles", [])
        if not profiles:
            st.warning("Filens 'profiles' √§r tomt.")
        else:
            def _label(i: int) -> str:
                p = profiles[i]
                t = (p.get("ticker") or "").strip()
                n = p.get("name") or p.get("profile") or f"Profil {i+1}"
                return f"{t} ‚Äì {n}" if t else n

            p_idx = st.selectbox("V√§lj profil", options=list(range(len(profiles))), format_func=_label, key="bf_prof_idx")
            chosen = profiles[p_idx]
if st.button("‚úÖ Anv√§nd i Backtest", key="bf_apply"):
    st.session_state["_pending_profile"] = chosen
    st.toast("Profil vald ‚Äì laddar ‚Ä¶")
    st.rerun()

# --- sidebar: Ladda profil (ny) ---
try:
    import glob, json, os
    import streamlit as st  # s√§kerst√§ll namn
    from app.profile_apply import queue_profile_apply as _prof_queue

    st.sidebar.markdown("### Ladda profil (ny)")
    _files = sorted(glob.glob("profiles/*.json"))
    sel_file = st.sidebar.selectbox("Profilfil", _files, key="bf_file_new") if _files else ""

    prof_names = []
    if sel_file:
        try:
            with open(sel_file, "r", encoding="utf-8") as _f:
                _data = json.load(_f)
            prof_names = [p.get("name") or f"Profil {i+1}" for i,p in enumerate(_data.get("profiles", []))]
        except Exception as _e:
            st.sidebar.error(f"Kunde inte l√§sa {sel_file}: {type(_e).__name__}: {_e}")

    sel_name = st.sidebar.selectbox("V√§lj profil", prof_names, key="bf_name_new") if prof_names else ""
    if st.sidebar.button("üì• Anv√§nd i Backtest", key="bf_apply_new") and sel_file and sel_name:
        _prof_queue(sel_file, sel_name)

except Exception as _e:
    try:
        st.sidebar.warning(f"[profil] Loader avst√§ngd: {type(_e).__name__}: {_e}")
    except Exception:
        print("[profil] Loader avst√§ngd:", type(_e).__name__, _e)
# --- /sidebar: Ladda profil (ny) ---

