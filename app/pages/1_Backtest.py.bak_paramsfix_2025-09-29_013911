# -*- coding: utf-8 -*-
import datetime as dt
from pathlib import Path
import pandas as pd
import streamlit as st

from app.data_providers import get_ohlcv as GET_OHLCV
from app.portfolio_signals import _import_backtest  # OBS: vi hÃ¤mtar inte _maybe_build_params hÃ¤r

st.set_page_config(page_title="Dala Trader â€“ Backtest (ren)", page_icon="ğŸ§ª", layout="wide")
st.title("ğŸ§ª Backtest (ren)")

# --- Debug UI ---
st.sidebar.subheader("ğŸ› ï¸ Debug")
DEBUG_KEY = "debug_enabled"
st.session_state.setdefault(DEBUG_KEY, True)
def d(msg: str):
    if st.session_state.get(DEBUG_KEY, False):
        st.sidebar.markdown(f"<small style='color:#2f7df6'>{msg}</small>", unsafe_allow_html=True)
st.sidebar.checkbox("Debug 0.4", value=st.session_state[DEBUG_KEY], key=DEBUG_KEY)

# --- Inputs ---
with st.sidebar:
    _BASE = Path(__file__).resolve().parents[1]
    _LOGO = _BASE / "assets" / "logodaladrader.png"
    if _LOGO.exists():
        st.image(str(_LOGO), width='stretch')
        st.markdown('<div style="height:8px"></div>', unsafe_allow_html=True)

today = dt.date.today()
default_start = today.replace(year=today.year-5)
ticker = st.text_input("Ticker", value=st.session_state.get("ticker", "HM-B.ST"), key="bt_ticker")
start  = st.date_input("Startdatum", value=st.session_state.get("from_date", default_start), key="bt_start")
end    = st.date_input("Slutdatum",  value=st.session_state.get("to_date", today), key="bt_end")
run_bt = st.button("KÃ¶r backtest", type="primary")

# --- HjÃ¤lpare: stÃ¤da/validera OHLCV ---
def coerce_ohlcv(obj):
    if obj is None:
        return None, "Ingen data (None) frÃ¥n datakÃ¤lla."
    if isinstance(obj, pd.DataFrame):
        df = obj.copy()
    else:
        try:
            df = pd.DataFrame(obj)
        except Exception as e:
            return None, f"Data -> DataFrame misslyckades: {e}"

    # Datumindex
    if not isinstance(df.index, pd.DatetimeIndex):
        for cand in ("date", "Date", "timestamp", "time", "Time"):
            if cand in df.columns:
                df[cand] = pd.to_datetime(df[cand], errors="coerce", utc=True)
                df = df.set_index(cand)
                break
        if not isinstance(df.index, pd.DatetimeIndex):
            try:
                df.index = pd.to_datetime(df.index, errors="coerce", utc=True)
            except Exception as e:
                return None, f"Kan inte tolka datumindex: {e}"

    df = df.sort_index()

    # Kolumnalias
    col_alias = {
        "open":   ("open","o","open_price"),
        "high":   ("high","h","high_price"),
        "low":    ("low","l","low_price"),
        "close":  ("close","c","close_price","adjclose","adj_close","price","last"),
        "volume": ("volume","v","vol","turnover"),
    }
    lower = {c.lower(): c for c in df.columns}
    for target, aliases in col_alias.items():
        if target not in df.columns:
            for a in aliases:
                if a in lower:
                    df = df.rename(columns={lower[a]: target})
                    break

    if "close" not in df.columns:
        return None, "Saknar 'close'-kolumn i data efter normalisering."
    return df, None

# --- KÃ¶rning ---
if run_bt:
    st.info(f"KÃ¶r backtest fÃ¶r **{ticker}**: {start} â†’ {end}")
    try:
        raw = GET_OHLCV(ticker, start, end)
        d("HÃ¤mtade data frÃ¥n GET_OHLCV().")
    except Exception as e:
        st.error(f"DatainlÃ¤sning misslyckades: {e}")
        d(f"GET_OHLCV error: {type(e).__name__}: {e}")
        st.stop()

    df, err = coerce_ohlcv(raw)
    if err:
        st.error(f"FÃ¶rbehandling av data misslyckades: {err}")
        d("coerce_ohlcv fel.")
        st.stop()

    d(f"Data klar: rader={len(df)}, datum {df.index.min().date()} â†’ {df.index.max().date()}.")

    # Backtest-"modul" (hos er: tuple)
    try:
        res = _import_backtest()
    except Exception as e:
        st.error(f"Kunde inte importera backtest: {e}")
        d(f"_import_backtest() fel: {e}")
        st.stop()

    run_fn = None
    ParamsCls = None

    # Hantera tuple (t.ex. (RUN_BT, Params)) *eller* modul
    if isinstance(res, tuple):
        d("HÃ¤mtade backtest: tuple")
        for x in res:
            if callable(x) and run_fn is None:
                run_fn = x
            elif isinstance(x, type) and ParamsCls is None:
                ParamsCls = x
        if run_fn is None:
            st.error("Tuple saknar kÃ¶rbar backtest-funktion.")
            st.stop()
    else:
        btmod = res
        d(f"HÃ¤mtade backtestmodul: {getattr(btmod,'__name__', type(btmod).__name__)}")
        for name in ("run_backtest","backtest","simulate","run"):
            f = getattr(btmod, name, None)
            if callable(f):
                run_fn = f
                break
        ParamsCls = getattr(btmod, "Params", None)
        if run_fn is None:
            st.error("Hittar ingen backtest-funktion i modulen (run_backtest/backtest/simulate/run).")
            st.stop()

    # Params â€“ fÃ¶rsÃ¶k endast Params(), anvÃ¤nd annars None
    params = None
    if ParamsCls is not None:
        try:
            params = ParamsCls()
            d("Params() instansierad.")
        except Exception as e:
            d(f"Params() misslyckades: {e}")

    # Prova anropskombinationer (aldrig 4 args)
    import inspect
    try:
        sig = inspect.signature(run_fn)
        d(f"Funktion: {run_fn.__name__}{sig}")
    except Exception:
        d(f"Funktion: {run_fn.__name__} (okÃ¤nd signatur)")

    tried = []
    result = None
    last_err = None
    combos = [
        (df, params),
        (df,),
    ]
    for args in combos:
        try:
            tried.append(f"{run_fn.__name__}{tuple(type(a).__name__ for a in args)}")
            result = run_fn(*args)
            break
        except TypeError as e:
            last_err = e
            d(f"TypeError pÃ¥ anrop {args}: {e}")
        except Exception as e:
            last_err = e
            d(f"Fel pÃ¥ anrop {args}: {e}")

    if result is None:
        st.error(f"Kunde inte anropa backtest-funktionen. Senaste fel: {last_err}")
        st.write("Testade kombinationer:", tried)
        st.stop()

    # Visa resultat
    if isinstance(result, tuple) and len(result) >= 2:
        eq, summ = result[0], result[1]
        st.subheader("Resultat (tuple)")
        if isinstance(eq, pd.DataFrame):
            st.line_chart(eq)
        st.json(summ)
    elif isinstance(result, dict):
        st.subheader("Resultat (dict)")
        st.json(result)
    elif isinstance(result, pd.DataFrame):
        st.subheader("Resultat (DataFrame)")
        st.dataframe(result.tail(50))
    else:
        st.subheader("Resultat (okÃ¤nd typ)")
        st.write(type(result).__name__)
        st.write(result)
