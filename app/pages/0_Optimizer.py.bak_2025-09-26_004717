# -*- coding: utf-8 -*-
from __future__ import annotations

import json
import datetime as dt
from pathlib import Path

import pandas as pd
import streamlit as st

from app.data_providers import get_ohlcv as GET_OHLCV
from app.portfolio_signals import (
    to_price_matrix,
    build_portfolio_with_caps,
    buyhold_equity_from_price,
    index_equity,
    _import_backtest,
    _maybe_build_params,
)

# -------- Helpers --------
PROFILES_DIR = Path("outputs/opt_results").resolve()

def _normalize_ticker(t: str) -> str:
    t2 = (t or "").strip().upper().replace(" ", "-")
    return t2 if t2.endswith(".ST") else (t2 + ".ST")

def _read_profiles(fp: Path) -> list[dict]:
    data = json.loads(fp.read_text(encoding="utf-8"))
    profs = data.get("profiles") or []
    # SÃ¤kerstÃ¤ll "name","params","metrics","ticker"
    out = []
    for p in profs:
        name = p.get("name") or p.get("profile") or fp.stem
        params = p.get("params") or {}
        metrics = p.get("metrics") or {}
        ticker = _normalize_ticker(p.get("ticker") or "")
        out.append({"name": name, "params": params, "metrics": metrics, "ticker": ticker})
    return out

def _discover_profile_files(pdir: Path) -> list[Path]:
    return sorted(p for p in pdir.glob("*.json") if p.is_file())

def _best_profile(profiles: list[dict]) -> dict | None:
    if not profiles:
        return None
    # vÃ¤lj hÃ¶gst TotalReturn om finns, annars fÃ¶rsta
    try:
        return max(profiles, key=lambda p: float(p.get("metrics", {}).get("TotalReturn", 0.0)))
    except Exception:
        return profiles[0]

# -------- UI --------
st.set_page_config(page_title="Dala Trader â€“ Optimizer", page_icon="ðŸ§ ", layout="wide")
st.title("ðŸ§  Optimizer (serverprofiler)")

with st.sidebar:
    st.subheader("InstÃ¤llningar")
    st.caption(f"Profilkatalog: `{PROFILES_DIR}`")

    files = _discover_profile_files(PROFILES_DIR)
    if not files:
        st.error("Hittar inga profiler i outputs/opt_results/. LÃ¤gg dit JSON-filerna (â€¦_best_backtrack.json).")
        st.stop()

    file_labels = [f"{fp.name}" for fp in files]
    file_idx = st.selectbox("VÃ¤lj optimeringsfil", options=list(range(len(files))),
                            format_func=lambda i: file_labels[i], index=0, key="opt_file_select")
    chosen_fp = files[file_idx]

    # LÃ¤s profiler i vald fil
    try:
        profiles = _read_profiles(chosen_fp)
    except Exception as e:
        st.error(f"Kunde inte lÃ¤sa {chosen_fp.name}: {e}")
        st.stop()

    if not profiles:
        st.error(f"Inga profiler i {chosen_fp.name}.")
        st.stop()

    prof_names = [p["name"] for p in profiles]
    # default till "bÃ¤sta"
    default_prof = _best_profile(profiles)
    def_idx = prof_names.index(default_prof["name"]) if default_prof else 0

    prof_idx = st.selectbox("VÃ¤lj profil i filen", options=list(range(len(profiles))),
                            index=def_idx, format_func=lambda i: prof_names[i], key="opt_profile_select")

    sel = profiles[prof_idx]
    ticker = sel["ticker"] or _normalize_ticker(chosen_fp.stem.split("_best")[0])
    start = st.date_input("Startdatum", value=dt.date(2020,1,1))
    end = st.date_input("Slutdatum", value=dt.date.today())
    index_ticker = st.text_input("Index-ticker (fÃ¶r jÃ¤mfÃ¶relse)", value="OMXS30")
    run = st.button("KÃ¶r backtest", type="primary")

# -------- KÃ¶rning --------
st.markdown(f"**Vald fil:** `{chosen_fp.name}`  |  **Profil:** `{sel['name']}`  |  **Ticker:** `{ticker}`")

# Visa profilens nyckelmetrik
m = sel.get("metrics", {})
colm1, colm2, colm3, colm4, colm5 = st.columns(5)
colm1.metric("TotalReturn", f"{m.get('TotalReturn', 0):.3f}")
colm2.metric("CAGR", f"{m.get('CAGR', 0):.3f}")
colm3.metric("SharpeD", f"{m.get('SharpeD', 0):.3f}")
colm4.metric("MaxDD", f"{m.get('MaxDD', 0):.3f}")
colm5.metric("Buy&Hold", f"{m.get('BuyHold', 0):.3f}")

if run:
    # 1) Priser
    try:
        dfp = GET_OHLCV(ticker, start=start, source="borsdata")
        dfp = dfp[(dfp.index.date >= start) & (dfp.index.date <= end)]
        if dfp.empty:
            st.error("Inga prisdata i vald period.")
            st.stop()
    except Exception as e:
        st.error(f"Kunde inte hÃ¤mta priser fÃ¶r {ticker}: {e}")
        st.stop()

    # 2) Backtest (fÃ¶r att fÃ¥ trades), och positions via equity-bygg
    try:
        RUN_BT, Params = _import_backtest()
        built_params = _maybe_build_params(Params, sel["params"])
        res = RUN_BT(dfp, built_params)  # ska returnera dict m. 'trades' och 'equity' eller liknande
        trades = res.get("trades")
    except Exception as e:
        st.error(f"Kunde inte kÃ¶ra backtest: {e}")
        st.stop()

    # 3) PortfÃ¶lj-equity frÃ¥n positioner: antag hel exponering nÃ¤r inne (vi anvÃ¤nder build_portfolio_with_caps)
    try:
        P = to_price_matrix({ticker: dfp})
        # Enkel positionsserie frÃ¥n trades (om equity saknas): vi bygger 1/0 perioder
        pos = pd.Series(0.0, index=dfp.index)
        if isinstance(trades, pd.DataFrame) and len(trades) > 0:
            # tolka EntryTime/ExitTime
            cols = {c.lower(): c for c in trades.columns}
            ed = next((cols.get(n) for n in ("entrytime","entry_time","entry","in","in_date")), None)
            xd = next((cols.get(n) for n in ("exittime","exit_time","exit","out","out_date")), None)
            ent = pd.to_datetime(trades[ed]).dt.normalize() if ed else pd.Series([], dtype="datetime64[ns]")
            exi = pd.to_datetime(trades[xd]).dt.normalize() if xd else pd.Series(pd.NaT, index=trades.index)
            for a,b in zip(ent, exi):
                if pd.isna(b) or b <= a:
                    pos.loc[pos.index.normalize() >= a] = 1.0
                else:
                    mask = (pos.index.normalize() >= a) & (pos.index.normalize() < b)
                    pos.loc[mask] = 1.0

        equity, _W = build_portfolio_with_caps({ticker: pos}, P, max_per_asset=1.0, max_total_equity=1.0, lag_days=1)
        port = equity["value"].rename("PortfÃ¶lj")
    except Exception as e:
        st.error(f"Kunde inte bygga portfÃ¶lj-kurva: {e}")
        st.stop()

    # 4) Buy&Hold + Index
    bh = buyhold_equity_from_price(P.iloc[:,0]).rename("Buy&Hold")
    idx = index_equity(index_ticker, start).rename(f"{index_ticker} (index)")
    bh = bh.reindex(port.index).ffill()
    idx = idx.reindex(port.index).ffill()

    def _norm(s: pd.Series) -> pd.Series:
        s = s.dropna()
        return s / float(s.iloc[0]) if len(s) else s

    chart = pd.concat([_norm(port), _norm(bh), _norm(idx)], axis=1).dropna(how="all")

    st.subheader("Kapitalutveckling (normaliserad till 1.0)")
    st.line_chart(chart, height=420)

    # 5) Trades
    st.subheader("Transaktioner")
    if isinstance(trades, pd.DataFrame) and len(trades):
        st.dataframe(trades, width='stretch')
        st.download_button(
            "Ladda ned trades (CSV)",
            trades.to_csv(index=False).encode("utf-8"),
            file_name=f"{ticker.replace(':','-')}_trades.csv",
            mime="text/csv",
        )
    else:
        st.info("Inga affÃ¤rer i perioden.")
# === PARAM UI (auto) ===
import streamlit as st
from datetime import date as _date

try:
    _defaults = default_ui_params()
except Exception:
    _defaults = {
        "use_trend_filter": False,
        "trend_ma_window": 100,
        "rsi_window": 8,
        "rsi_min": 30.0,
        "rsi_max": 70.0,
        "breakout_lookback": 55,
        "exit_lookback": 20,
        "use_macd_filter": False,
        "macd_fast": 12,
        "macd_slow": 26,
        "macd_signal": 9,
        "use_bb_filter": False,
        "bb_window": 20,
        "bb_nstd": 2.0,
        "bb_min": 0.5,
        "use_stop_loss": True,
        "stop_mode": "pct",
        "stop_loss_pct": 0.08,
        "atr_window": 14,
        "atr_mult": 2.0,
        "use_atr_trailing": False,
        "atr_trail_mult": 1.5,
    }

for k, v in _defaults.items():
    st.session_state.setdefault(k, v)

st.session_state.setdefault("ticker", st.session_state.get("ticker", "VOLV B"))
st.session_state.setdefault("from_date", st.session_state.get("from_date", "2020-01-01"))
st.session_state.setdefault("to_date", st.session_state.get("to_date", _date.today().isoformat()))

with st.expander("âš™ï¸ Parametrar", expanded=True):
    c1, c2 = st.columns(2)

    with c1:
        st.text_input("Ticker", key="ticker")
        st.text_input("FrÃ¥n (YYYY-MM-DD)", key="from_date")
        st.text_input("Till (YYYY-MM-DD)", key="to_date")

        st.checkbox("EMA trend-gate", key="use_trend_filter")
        st.number_input("EMA-fÃ¶nster", min_value=5, max_value=300, step=1, key="trend_ma_window")
        st.number_input("RSI-fÃ¶nster", min_value=5, max_value=50, step=1, key="rsi_window")
        st.number_input("RSI min (kÃ¶p-kors upp)", min_value=5.0, max_value=50.0, step=0.5, key="rsi_min")
        st.number_input("RSI max (sÃ¤lj-kors ned)", min_value=50.0, max_value=95.0, step=0.5, key="rsi_max")
        st.number_input("Breakout lookback (0=av)", min_value=0, max_value=200, step=1, key="breakout_lookback")

    with c2:
        st.number_input("Exit lookback (0=av)", min_value=0, max_value=200, step=1, key="exit_lookback")
        st.checkbox("MACD-filter (histogram > 0)", key="use_macd_filter")
        st.number_input("MACD fast", min_value=3, max_value=30, step=1, key="macd_fast")
        st.number_input("MACD slow", min_value=5, max_value=60, step=1, key="macd_slow")
        st.number_input("MACD signal", min_value=2, max_value=30, step=1, key="macd_signal")

        st.checkbox("Bollinger %B-filter", key="use_bb_filter")
        st.number_input("BB fÃ¶nster", min_value=5, max_value=60, step=1, key="bb_window")
        st.number_input("BB std", min_value=1.0, max_value=5.0, step=0.1, key="bb_nstd")
        st.number_input("%B â‰¤ (entry-tak)", min_value=0.0, max_value=1.0, step=0.05, key="bb_min")

        st.checkbox("Aktivera stop-loss", key="use_stop_loss")
        st.selectbox("Stop-mod", options=["pct","atr"],
                     index=0 if st.session_state.get("stop_mode","pct")=="pct" else 1,
                     key="stop_mode")
        st.number_input("Stop % (vid pct)", min_value=0.01, max_value=0.50, step=0.01, key="stop_loss_pct")
        st.number_input("ATR fÃ¶nster", min_value=5, max_value=100, step=1, key="atr_window")
        st.number_input("ATR multipel", min_value=0.5, max_value=5.0, step=0.1, key="atr_mult")
        st.checkbox("ATR trailing", key="use_atr_trailing")
        st.number_input("ATR trailing multipel", min_value=0.5, max_value=5.0, step=0.1, key="atr_trail_mult")
# === END PARAM UI (auto) ===
# === OPTIMIZER (random search) ===============================================
import json, re, random, datetime as dt
import numpy as np
import pandas as pd
import streamlit as st
from pathlib import Path
from app.portfolio_signals import _import_backtest, _maybe_build_params
from app.data_providers import get_ohlcv as GET_OHLCV

def _norm_ticker(t: str) -> str:
    t = (t or "").strip().upper().replace("_","-").replace(" ", "-")
    return t if t.endswith(".ST") else (t + ".ST")

def _clip(v, lo, hi): 
    return max(lo, min(hi, v))

def _sample_params() -> dict:
    # Slumpa Ã¶ver rimliga intervall
    # (enkelt & robust â€“ rÃ¤cker fint fÃ¶r en demo/random search)
    use_trend = random.choice([True, False])
    use_macd  = random.choice([True, False])
    use_bb    = random.choice([True, False])
    use_sl    = random.choice([True, False])
    stop_mode = random.choice(["pct","atr"])
    use_trail = random.choice([True, False])

    rsi_min = round(random.uniform(5.0, 45.0), 1)
    rsi_max = round(random.uniform(55.0, 90.0), 1)
    if rsi_max <= rsi_min + 5.0:
        rsi_max = _clip(rsi_min + 5.0, 55.0, 90.0)

    macd_fast = random.randint(3, 30)
    macd_slow = random.randint(max(macd_fast+1, 5), 60)  # slow > fast
    macd_signal = random.randint(2, 30)

    params = {
        "use_trend_filter": use_trend,
        "trend_ma_window": random.randint(5, 300),

        "rsi_window": random.randint(5, 50),
        "rsi_min": rsi_min,
        "rsi_max": rsi_max,

        "breakout_lookback": random.randint(0, 200),
        "exit_lookback": random.randint(0, 200),

        "use_macd_filter": use_macd,
        "macd_fast": macd_fast,
        "macd_slow": macd_slow,
        "macd_signal": macd_signal,

        "use_bb_filter": use_bb,
        "bb_window": random.randint(5, 60),
        "bb_nstd": round(random.uniform(1.0, 5.0), 1),
        "bb_min": round(random.uniform(0.0, 1.0), 2),

        "use_stop_loss": use_sl,
        "stop_mode": stop_mode,
        "stop_loss_pct": round(random.uniform(0.01, 0.50), 2),

        "atr_window": random.randint(5, 100),
        "atr_mult": round(random.uniform(0.5, 5.0), 1),
        "use_atr_trailing": use_trail,
        "atr_trail_mult": round(random.uniform(0.5, 5.0), 1),
    }
    return params

def _score(summary: dict, target: str) -> float:
    try:
        return float(summary.get(target, float("-inf")))
    except Exception:
        return float("-inf")

st.divider()
st.subheader("ðŸ§ª Optimizer (random search)")

c1, c2, c3, c4 = st.columns(4)
N    = int(c1.number_input("Simuleringar (N)", 10, 100_000, 200, step=50, key="opt_N"))
seed = int(c2.number_input("SlumpfrÃ¶", 0, 999_999, 42, step=1, key="opt_seed"))
target = c3.selectbox("MÃ¥lfunktion", ["SharpeD", "TotalReturn", "CAGR"], index=0, key="opt_target")
start_btn = c4.button("Starta optimering", type="primary", key="opt_start")

if start_btn:
    random.seed(seed); np.random.seed(seed)

    # Plocka datum & ticker frÃ¥n UI (Parametrar-rutan vi lade tillbaka)
    _t_raw = st.session_state.get("ticker", "VOLV B")
    _t = _norm_ticker(_t_raw)
    try:
        _from = dt.date.fromisoformat(st.session_state.get("from_date", "2020-01-01"))
    except Exception:
        _from = dt.date(2020,1,1)

    st.info(f"KÃ¶r optimering fÃ¶r **{_t}** frÃ¥n **{_from.isoformat()}** â€¦")
    df = GET_OHLCV(_t, start=_from, source="borsdata")

    RUN_BT, Params = _import_backtest()

    prog = st.progress(0.0, text="Initierar â€¦")
    best = {"score": float("-inf"), "params": None, "summary": None}
    rows = []

    for i in range(1, N+1):
        cand = _sample_params()
        built = _maybe_build_params(Params, cand)
        try:
            res = RUN_BT(df, built)  # vi vet att denna ger dict med 'summary'
            summ = res.get("summary", {})
            sc = _score(summ, target)
            rows.append({"i": i, "score": sc, **{k: summ.get(k) for k in ("SharpeD","TotalReturn","CAGR","MaxDD","FinalEquity")}})
            if sc > best["score"]:
                best = {"score": sc, "params": cand, "summary": summ}
        except Exception as e:
            rows.append({"i": i, "score": -1e9, "error": str(e)})

        if i % max(1, N//100) == 0 or i == N:
            prog.progress(i/N, text=f"KÃ¶r {i}/{N} â€¦ bÃ¤sta {target} = {best['score']:.4f}")

    prog.empty()

    # Visa resultat
    st.success(f"BÃ¤st {target}: **{best['score']:.4f}**")
    colA, colB = st.columns(2)
    with colA:
        st.markdown("**BÃ¤sta parametrar**")
        st.json(best["params"])
    with colB:
        st.markdown("**BÃ¤sta sammanfattning**")
        st.json(best["summary"])

    # Topplista
    try:
        dfres = pd.DataFrame(rows).sort_values("score", ascending=False).head(25)
        st.markdown("**Top 25 kandidater**")
        st.dataframe(dfres, width='stretch')
    except Exception:
        pass

    # Spara som profil
    def _file_safe(name: str) -> str:
        name = name.upper()
        name = re.sub(r"[^A-Z0-9]+", "_", name).strip("_")
        return name

    if st.button("ðŸ’¾ Spara bÃ¤sta som profil (JSON)", key="opt_save_best"):
        outdir = Path("outputs/opt_results"); outdir.mkdir(parents=True, exist_ok=True)
        base = _file_safe(_t_raw) or _file_safe(_t)
        fp = outdir / f"{base}_final.json"
        payload = {
            "profiles": [{
                "ticker": _t,
                "name": f"{_t_raw} â€“ optimized",
                "params": best["params"],
            }],
            "summary": best["summary"],
            "created": dt.datetime.utcnow().isoformat()+"Z",
            "target": target,
            "random_search": {"N": N, "seed": seed},
        }
        fp.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")
        st.success(f"Sparat: `{fp}`")
# === END OPTIMIZER ============================================================
