# -*- coding: utf-8 -*-
from __future__ import annotations

import json, random, math
from datetime import date
from typing import Dict, Any, List

import pandas as pd
import streamlit as st

# Branding (valfritt)
try:
    from app.branding import apply as brand
except Exception:
    def brand(*a, **k): pass

# Backtest-wrap (UI-oberoende entrypoint vi redan anvÃ¤nt)
try:
    from app.btwrap import run_backtest as RUN_BT
except Exception:
    RUN_BT = None

brand(page_title="Dala Trader â€“ Optimizer", page_icon="âš™ï¸")

st.title("âš™ï¸ Optimizer (steg 2)")
st.caption("KÃ¶r simuleringar, visar en tabell och kan spara tre profiler. Inga grafer Ã¤nnu.")


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Diagnostik
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# â”€â”€ diag: safe defaults (do not depend on widgets) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
try:
    from app.btwrap import run_backtest as RUN_BT
except Exception:
    RUN_BT = None
ticker = (st.session_state.get("ticker") or st.session_state.get("opt_ticker") or "").strip()
from_date = st.session_state.get("from_date") or st.session_state.get("opt_from") or ""
to_date   = st.session_state.get("to_date")   or st.session_state.get("opt_to")   or ""
if "sample_params" not in globals():
    def sample_params(_rng):
        return {}
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

with st.sidebar.expander("Diagnostik", expanded=False):
    st.write("**RUN_BT importerat?**", "âœ…" if RUN_BT else "âŒ")
    st.write("**Ticker**:", ticker)
    st.write("**FrÃ¥n/Till**:", from_date, "â†’", to_date)
    if st.button("ðŸ”Ž Testa 1 kÃ¶rning (snabb)"):
        if RUN_BT is None:
            st.error("RUN_BT Ã¤r None â€“ kan inte kÃ¶ra backtest. Kontrollera app.btwrap.")
        elif not ticker:
            st.error("Ange en ticker fÃ¶rst.")
        else:
            try:
                _profile = {"ticker": ticker, "params": sample_params(__import__("random").Random(123))}
                _res = RUN_BT(_profile)
                _summ = _res.get("summary", {}) if isinstance(_res, dict) else {}
                st.success("OK â€“ fick svar frÃ¥n backtest")
                st.json({"summary": _summ})
            except Exception as _e:
                import traceback as _tb
                st.error(f"Backtest fel: {type(_e).__name__}: {_e}")
                st.code(_tb.format_exc())

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Indata
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
c1, c2, c3 = st.columns(3)
with c1:
    ticker = st.text_input("Ticker", value=st.session_state.get("opt_ticker", "GETI B"), key="opt_ticker")
with c2:
    from_date = st.text_input("FrÃ¥n (YYYY-MM-DD)", value=st.session_state.get("opt_from_date", "2020-10-01"), key="opt_from_date")
with c3:
    to_date   = st.text_input("Till (YYYY-MM-DD)", value=st.session_state.get("opt_to_date", "2025-10-01"), key="opt_to_date")

c4, c5, c6 = st.columns(3)
with c4:
    sims = st.number_input("Antal simuleringar", min_value=100, max_value=100_000, step=100, value=1000, key="opt_sims")
with c5:
    seed = st.number_input("Slumptals-seed", min_value=0, max_value=1_000_000, step=1, value=42, key="opt_seed")
with c6:
    score_metric = st.selectbox("Score", options=["SharpeD","TotalReturn"], index=0, key="opt_score_metric")

st.divider()

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Parametrar â€“ sampling enligt dina spann
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def _ur(a: float, b: float, rng: random.Random) -> float:
    return a + (b - a) * rng.random()

def sample_params(rng: random.Random) -> Dict[str, Any]:
    use_trend_filter = rng.choice([True, False])
    use_macd_filter  = rng.choice([True, False])
    use_bb_filter    = rng.choice([True, False])
    use_stop_loss    = rng.choice([True, False])
    use_atr_trailing = rng.choice([True, False])
    trend_ma_type    = rng.choice(["EMA", "SMA"])

    return {
        "from_date":       st.session_state.get("opt_from_date") or from_date,
        "to_date":         st.session_state.get("opt_to_date") or to_date,

        "use_rsi_filter":  True,
        "rsi_window":      rng.randint(5, 35),
        "rsi_min":         _ur(5.0, 35.0, rng),
        "rsi_max":         _ur(60.0, 85.0, rng),

        "use_trend_filter": use_trend_filter,
        "trend_ma_type":    trend_ma_type,
        "trend_ma_window":  rng.randint(20, 200),

        "breakout_lookback": rng.randint(20, 120),
        "exit_lookback":     rng.randint(10, 60),

        "use_macd_filter": use_macd_filter,
        "macd_fast":   rng.randint(8, 16),
        "macd_slow":   rng.randint(18, 30),
        "macd_signal": rng.randint(8, 14),

        "use_bb_filter": use_bb_filter,
        "bb_window": rng.randint(15, 30),
        "bb_nstd":   _ur(1.6, 2.4, rng),
        "bb_min":    _ur(0.0, 0.8, rng),

        "use_stop_loss": use_stop_loss,
        "stop_mode": rng.choice(["pct", "atr"]),
        "stop_loss_pct": _ur(0.03, 0.20, rng),

        "atr_window": rng.randint(10, 20),
        "atr_mult":   _ur(1.2, 3.2, rng),

        "use_atr_trailing": use_atr_trailing,
        "atr_trail_mult":   _ur(1.2, 3.5, rng),
    }

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# KÃ¶r simuleringar
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def run_sims(ticker: str, sims: int, seed: int) -> pd.DataFrame:
    rows: List[Dict[str, Any]] = []
    if not RUN_BT:
        st.error("RUN_BT saknas â€“ kan inte kÃ¶ra backtest.")
        return pd.DataFrame()

    rng = random.Random(int(seed))
    for i in range(int(sims)):
        p = sample_params(rng)
        profile = {"ticker": ticker, "params": p}
        try:
            res = RUN_BT(profile)
            summ = res.get("summary", {}) if isinstance(res, dict) else {}
            rows.append({
                "SharpeD":       summ.get("SharpeD"),
                "TotalReturn":   summ.get("TotalReturn"),
                "MaxDD":         summ.get("MaxDD"),
                "BuyHold":       summ.get("BuyHold"),
                "FinalEquity":   summ.get("FinalEquity"),
                "Trades":        summ.get("Trades"),
                "Bars":          summ.get("Bars"),
                "params":        p,
            })
        except Exception as e:
            # Spara felrad med minimal info sÃ¥ vi kan felsÃ¶ka vid behov
            rows.append({
                "SharpeD": None, "TotalReturn": None, "MaxDD": None,
                "BuyHold": None, "FinalEquity": None, "Trades": None, "Bars": None,
                "params": p, "error": f"{type(e).__name__}: {e}",
            })

    df = pd.DataFrame(rows)
    # Score & sortering
    if score_metric == "SharpeD":
        df["score"] = pd.to_numeric(df["SharpeD"], errors="coerce")
    else:
        df["score"] = pd.to_numeric(df["TotalReturn"], errors="coerce")
    df = df.sort_values(["score"], ascending=[False], na_position="last").reset_index(drop=True)
    return df

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# UI: KÃ¶rning + visning
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
run = st.button("ðŸš€ KÃ¶r simuleringar", type="primary", width='stretch')

df = None
if run:
    if not ticker.strip():
        st.error("Ange en ticker.")
    else:
        with st.spinner(f"KÃ¶r {sims} simuleringar pÃ¥ {ticker}â€¦"):
            df = run_sims(ticker.strip(), sims=int(sims), seed=int(seed))

if df is not None and len(df):
    st.success(f"Hittade {len(df)} kÃ¶rningar.")
    show_cols = ["score","SharpeD","TotalReturn","MaxDD","Trades","FinalEquity","Bars"]
    st.dataframe(df[show_cols].head(30), width='stretch')

    # VÃ¤lj 3 profiler fÃ¶r sparning
    st.subheader("Spara tre profiler (conservative/balanced/aggressive)")
    top = df.dropna(subset=["score"]).head(100) if len(df) > 100 else df.dropna(subset=["score"])
    if len(top) == 0:
        st.info("Inga giltiga kÃ¶rningar i toppen.")
    else:
        # Heuristik:
        # - aggressive: rad 1
        # - balanced : median i topp 10 (eller mitt i topp om <10)
        # - conservative: bÃ¤sta (min MaxDD) bland topp 30 (eller topp N)
        aggressive = top.iloc[0]["params"]

        t10 = top.head(10) if len(top) >= 10 else top
        balanced = t10.iloc[len(t10)//2]["params"]

        t30 = top.head(30) if len(top) >= 30 else top
        t30 = t30.copy()
        t30["absDD"] = t30["MaxDD"].apply(lambda x: abs(x) if pd.notna(x) else math.inf)
        t30 = t30.sort_values("absDD")
        conservative = t30.iloc[0]["params"]

        default_names = {
            "conservative": f"{ticker} â€“ conservative",
            "balanced":     f"{ticker} â€“ balanced",
            "aggressive":   f"{ticker} â€“ aggressive",
        }

        cA, cB, cC = st.columns(3)
        with cA:
            name_cons = st.text_input("Namn (conservative)", value=default_names["conservative"])
        with cB:
            name_bal  = st.text_input("Namn (balanced)", value=default_names["balanced"])
        with cC:
            name_aggr = st.text_input("Namn (aggressive)", value=default_names["aggressive"])

        out = {
            "profiles": [
                {"name": name_cons, "ticker": ticker, "params": conservative},
                {"name": name_bal,  "ticker": ticker, "params": balanced},
                {"name": name_aggr, "ticker": ticker, "params": aggressive},
            ]
        }

        # Spara
        outdir = st.text_input("Output-katalog", value="profiles")
        fname  = st.text_input("Filnamn", value=f"{ticker}.json")
        if st.button("ðŸ’¾ Spara profiler", width='stretch'):
            try:
                import os
                os.makedirs(outdir, exist_ok=True)
                path = f"{outdir.rstrip('/')}/{fname}"
                with open(path, "w", encoding="utf-8") as f:
                    json.dump(out, f, ensure_ascii=False, indent=2)
                st.success(f"Sparat: {path}")
                st.code(json.dumps(out, ensure_ascii=False, indent=2))
            except Exception as e:
                st.error(f"Kunde inte spara: {type(e).__name__}: {e}")

else:
    st.info("Tryck pÃ¥ **KÃ¶r simuleringar** fÃ¶r att starta.")

