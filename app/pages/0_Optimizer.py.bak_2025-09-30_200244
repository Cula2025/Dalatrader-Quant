# -*- coding: utf-8 -*-
from __future__ import annotations

import json
import math
import random
from datetime import date, datetime
from pathlib import Path
from typing import Dict, Any, List

import numpy as np
import pandas as pd
import streamlit as st

# Branding (frivillig)
try:
    from app.branding import apply as brand
except Exception:
    def brand(*a, **k): pass

brand(page_title="Dala Trader â€“ Optimizer", page_icon="âš™ï¸")

st.title("âš™ï¸ Optimizer")
st.caption("Slumpa mÃ¥nga parametrar (Monte Carlo), vÃ¤lj tre profiler per ticker (conservative/balanced/aggressive) och spara som JSON.")

# -----------------------------
# UI â€“ indata
# -----------------------------
colA, colB, colC = st.columns([1,1,1], vertical_alignment="bottom")
with colA:
    ticker = st.text_input("Ticker", value=st.session_state.get("ticker","VOLV-B.ST")).strip()
with colB:
    from_date = st.date_input("FrÃ¥n", value=date(2020,9,29))
with colC:
    to_date   = st.date_input("Till",  value=date(2025,9,29))

col1, col2, col3, col4 = st.columns([1,1,1,1], vertical_alignment="bottom")
with col1:
    n_sims = st.number_input("Antal simuleringar", min_value=100, max_value=100000, step=100, value=10000)
with col2:
    seed = st.number_input("SlumpfrÃ¶", min_value=0, max_value=1_000_000_000, step=1, value=42)
with col3:
    show_table = st.checkbox("Visa full resultat-tabell", value=False)
with col4:
    run_btn = st.button("ðŸš€ KÃ¶r optimering")

st.markdown("---")

def _ticker_label(t: str) -> str:
    t = (t or "").strip()
    if t.upper().endswith(".ST"):
        t = t[:-3]
    return t.replace("-", " ").strip() or "TICKER"

def _years_between(a: date, b: date) -> float:
    days = abs((b - a).days)
    return max(days / 365.25, 1e-9)

# PoÃ¤ngfunktion â€“ vÃ¤ga SharpeD hÃ¶gst, sen TotalReturn, mild bonus fÃ¶r mindre (mindre negativ) MaxDD
def _score_row(r: Dict[str, Any]) -> float:
    sharpe = float(r.get("SharpeD", 0.0) or 0.0)
    tr     = float(r.get("TotalReturn", 0.0) or 0.0)
    maxdd  = float(r.get("MaxDD", -1.0) or -1.0)
    return sharpe*1.0 + tr*0.3 + maxdd*0.2

# Slumpa en parameteruppsÃ¤ttning (hÃ¥ll intervallet rimligt men brett)
def _rand_params(rng: random.Random) -> Dict[str, Any]:
    # bool med 50% sannolikhet
    b50 = lambda: bool(rng.getrandbits(1))
    # floats
    def ur(a,b): return a + (b-a)*rng.random()

    # strategiflaggor
    use_rsi_filter   = b50()
    use_trend_filter = b50()
    use_macd_filter  = b50()
    use_bb_filter    = b50()
    use_stop_loss    = b50()
    use_atr_trailing = b50()

    trend_ma_type = rng.choice(["SMA","EMA"])

    params = {
        "use_rsi_filter": use_rsi_filter,
        "rsi_window":     rng.randint(5, 35),
        "rsi_min":        ur(5.0, 35.0),
        "rsi_max":        ur(60.0, 85.0),

        "use_trend_filter": use_trend_filter,
        "trend_ma_type":  trend_ma_type,
        "trend_ma_window": rng.randint(20, 200),

        "breakout_lookback": rng.randint(20, 120),
        "exit_lookback":     rng.randint(10, 60),

        "use_macd_filter": use_macd_filter,
        "macd_fast":   rng.randint(8, 16),
        "macd_slow":   rng.randint(18, 30),
        "macd_signal": rng.randint(8, 14),

        "use_bb_filter": use_bb_filter,
        "bb_window": rng.randint(15, 30),
        "bb_nstd":   ur(1.6, 2.4),
        "bb_min":    ur(0.0, 0.8),

        "use_stop_loss": use_stop_loss,
        "stop_mode": rng.choice(["pct","atr"]),
        "stop_loss_pct": ur(0.03, 0.20),

        "atr_window": rng.randint(10, 20),
        "atr_mult":   ur(1.2, 3.2),

        "use_atr_trailing": use_atr_trailing,
        "atr_trail_mult":   ur(1.2, 3.5),
    }
    return params

def _run_one(profile: Dict[str, Any]) -> Dict[str, Any]:
    # KÃ¶r via btwrap (samma vÃ¤g som UI)
    from app.btwrap import run_backtest
    res = run_backtest(profile)
    summ = res.get("summary", {}) if isinstance(res, dict) else {}
    out: Dict[str, Any] = {}
    # kopiera metrics vi bryr oss om
    for k in ("TotalReturn","MaxDD","SharpeD","BuyHold","FinalEquity","Bars","Trades"):
        out[k] = summ.get(k)
    return out

def _build_profile(ticker: str, params: Dict[str, Any], from_date: str, to_date: str) -> Dict[str, Any]:
    p = params.copy()
    p["from_date"] = from_date
    p["to_date"]   = to_date
    return {"ticker": ticker, "params": p}

if run_btn:
    if not ticker:
        st.error("Ange en ticker.")
        st.stop()

    rng = random.Random(int(seed))
    rows: List[Dict[str,Any]] = []

    # KÃ¶r Monte Carlo
    with st.spinner(f"KÃ¶r {int(n_sims):,} simuleringar â€¦"):
        for i in range(int(n_sims)):
            params = _rand_params(rng)
            prof = _build_profile(ticker, params, str(from_date), str(to_date))
            try:
                metrics = _run_one(prof)
                # bygg rad
                row = params.copy()
                row.update(metrics)
                rows.append(row)
            except Exception as e:
                # spara felrad om du vill analysera â€” hÃ¤r hoppar vi bara
                pass

    if not rows:
        st.error("Inga resultat (alla kÃ¶rningar felade?).")
        st.stop()

    df = pd.DataFrame(rows)
    # rensa konstigheter
    df = df.replace([np.inf, -np.inf], np.nan)
    df = df.dropna(subset=["TotalReturn","MaxDD","SharpeD"], how="any")
    if df.empty:
        st.error("Alla resultat saknar nÃ¶dvÃ¤ndiga metrics.")
        st.stop()

    # CAGR (approx) frÃ¥n periodlÃ¤ngd
    yrs = _years_between(from_date, to_date)
    with np.errstate(invalid="ignore"):
        df["CAGR"] = ((1.0 + df["TotalReturn"].astype(float)) ** (1.0/yrs)) - 1.0

    # score
    df["Score"] = df.apply(lambda r: _score_row(r.to_dict()), axis=1)

    # risk-buckets pÃ¥ MaxDD (mer negativ = hÃ¶gre risk)
    q1, q2 = df["MaxDD"].quantile([0.33, 0.66])
    low_risk  = df[df["MaxDD"] >= q2]                             # minst DD
    mid_risk  = df[(df["MaxDD"] < q2) & (df["MaxDD"] >= q1)]
    high_risk = df[df["MaxDD"] < q1]                              # stÃ¶rst DD

    pick_cons = low_risk.sort_values(["Score","SharpeD","TotalReturn"], ascending=False).head(1)
    pick_bal  = mid_risk.sort_values(["Score","SharpeD","TotalReturn"], ascending=False).head(1)
    pick_aggr = high_risk.sort_values(["TotalReturn","Score","SharpeD"], ascending=False).head(1)

    # packa profiler
    param_keys = [
        "use_rsi_filter","rsi_window","rsi_min","rsi_max",
        "use_trend_filter","trend_ma_type","trend_ma_window",
        "breakout_lookback","exit_lookback",
        "use_macd_filter","macd_fast","macd_slow","macd_signal",
        "use_bb_filter","bb_window","bb_nstd","bb_min",
        "use_stop_loss","stop_mode","stop_loss_pct","atr_window","atr_mult",
        "use_atr_trailing","atr_trail_mult",
    ]

    def _row_to_profile(row: pd.Series, name_prefix: str, ticker_label: str) -> Dict[str, Any]:
        r = row.to_dict()
        params = {k: r[k] for k in param_keys if k in r}
        metrics = {
            "TotalReturn": float(r.get("TotalReturn", 0.0) or 0.0),
            "MaxDD":       float(r.get("MaxDD", 0.0) or 0.0),
            "SharpeD":     float(r.get("SharpeD", 0.0) or 0.0),
            "BuyHold":     float(r.get("BuyHold", 0.0) or 0.0),
            "CAGR":        float(r.get("CAGR", 0.0) or 0.0),
        }
        return {
            "name":   f"{ticker_label} â€“ {name_prefix}",
            "ticker": ticker_label,
            "params": params,
            "metrics": metrics,
        }

    label = _ticker_label(ticker)
    profiles: List[Dict[str, Any]] = []
    if len(pick_cons): profiles.append(_row_to_profile(pick_cons.iloc[0], "conservative", label))
    if len(pick_bal):  profiles.append(_row_to_profile(pick_bal.iloc[0],  "balanced",     label))
    if len(pick_aggr): profiles.append(_row_to_profile(pick_aggr.iloc[0], "aggressive",   label))

    out = {"profiles": profiles}

    # spara fil
    outdir = Path("profiles_out")
    outdir.mkdir(exist_ok=True)
    outfile = outdir / f"{label.replace(' ','_').upper()}_optimized.json"
    outfile.write_text(json.dumps(out, ensure_ascii=False, indent=2), encoding="utf-8")

    # UI-output
    st.success(f"Sparade tre profiler till: {outfile}")
    if show_table:
        st.dataframe(df.sort_values("Score", ascending=False).reset_index(drop=True))
    st.json(out)

else:
    st.info("Fyll i ticker och period, vÃ¤lj antal simuleringar, klicka sedan **KÃ¶r optimering**.")
