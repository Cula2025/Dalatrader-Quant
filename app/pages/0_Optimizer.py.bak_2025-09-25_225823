# --- branding (safe no-op om modul saknas) ---
from __future__ import annotations
try:
    from app.branding import apply as _brand
except Exception:
    def _brand(*a, **k): pass
_brand()
# --- end branding ---

import json
import math
import random
import datetime as dt
from pathlib import Path
from typing import Any, Dict, Tuple

import numpy as np
import pandas as pd
import streamlit as st
st.markdown("""<style>[data-testid=stWidgetKey]{display:none!important}</style>""", unsafe_allow_html=True)

from pathlib import Path as _Path
import json as _json

def _discover_tickers_from_profiles(pdir: _Path) -> list[str]:
    out = set()
    if not pdir.exists():
        return []
    for fp in sorted(pdir.glob("*.json")):
        try:
            data = _json.loads(fp.read_text(encoding="utf-8"))
            for prof in data.get("profiles", []):
                t = prof.get("ticker")
                if isinstance(t, str) and t.strip():
                    t2 = t.strip().upper().replace(" ", "-")
                    if not t2.endswith(".ST"):
                        t2 += ".ST"
                    out.add(t2)
        except Exception:
            stem = fp.stem.split("_best")[0]
            t2 = stem.replace("_", "-").upper()
            if not t2.endswith(".ST"):
                t2 += ".ST"
            out.add(t2)
    return sorted(out)


# Disable local upload widgets
up = None

# =========================
# Robust import av motor + data
# =========================
def _import_backtest():
    try:
        from backtest import run_backtest, Params   # C:\trader\backtest.py
        return run_backtest, Params
    except Exception:
        pass
    try:
        from app.backtest import run_backtest, Params  # fallback
        return run_backtest, Params
    except Exception as e:
        st.error("Hittade inte backtest-motorn. L√§gg den som C:\\trader\\backtest.py eller app/backtest.py")
        raise e

RUN_BT, PARAMS_CLASS = _import_backtest()

def _import_get_ohlcv():
    try:
        from app.data_providers import get_ohlcv
        return get_ohlcv
    except Exception as e:
        st.error("Hittade inte app.data_providers.get_ohlcv ‚Äì kontrollera din kodbas.")
        raise e

GET_OHLCV = _import_get_ohlcv()

# =========================
# Hj√§lp: data och params
# =========================
def normalize_df(df: pd.DataFrame) -> pd.DataFrame:
    x = pd.DataFrame(df).copy()
    if "Date" not in x.columns:
        idx = x.index.name or "Date"
        x = x.reset_index().rename(columns={idx: "Date"})
    x["Date"] = pd.to_datetime(x["Date"], errors="coerce")
    for c in ("Open","High","Low","Close","Volume"):
        if c in x.columns:
            x[c] = pd.to_numeric(x[c], errors="coerce")
    return x.dropna(subset=["Date","Close"]).sort_values("Date").reset_index(drop=True)

def default_ui_params() -> Dict[str, Any]:
    return dict(
        # RSI
        rsi_window=14, rsi_min=25.0, rsi_max=60.0,
        # Trend
        use_trend_filter=True, trend_ma_type="EMA", trend_ma_window=100,
        # Donchian
        breakout_lookback=55, exit_lookback=20,
        # MACD
        use_macd_filter=False, macd_fast=12, macd_slow=26, macd_signal=9,
        # Bollinger
        use_bb_filter=False, bb_window=20, bb_nstd=2.0, bb_min=0.2,
        # Stop
        use_stop_loss=False, stop_mode="pct", stop_loss_pct=0.08, atr_window=14, atr_mult=2.0,
    )

def make_params_from_state() -> Dict[str, Any]:
    """Plocka paramv√§rden fr√•n widgets/STATE till params-dict."""
    return dict(
        # RSI
        use_rsi_filter=True,
        rsi_window=int(st.session_state["rsi_window"]),
        rsi_min=float(st.session_state["rsi_min"]),
        rsi_max=float(st.session_state["rsi_max"]),
        # Trend
        use_trend_filter=bool(st.session_state["use_trend_filter"]),
        trend_ma_type="EMA",
        trend_ma_window=int(st.session_state["trend_ma_window"]) if st.session_state["use_trend_filter"] else 0,
        # Donchian
        breakout_lookback=int(st.session_state["breakout_lookback"]),
        exit_lookback=int(st.session_state["exit_lookback"]),
        # MACD
        use_macd_filter=bool(st.session_state["use_macd_filter"]),
        macd_fast=int(st.session_state["macd_fast"]),
        macd_slow=int(st.session_state["macd_slow"]),
        macd_signal=int(st.session_state["macd_signal"]),
        # Bollinger
        use_bb_filter=bool(st.session_state["use_bb_filter"]),
        bb_window=int(st.session_state["bb_window"]),
        bb_nstd=float(st.session_state["bb_nstd"]),
        bb_min=float(st.session_state["bb_min"]),
        # Stop
        use_stop_loss=bool(st.session_state["use_stop_loss"]),
        stop_mode=st.session_state["stop_mode"],
        stop_loss_pct=float(st.session_state["stop_loss_pct"]),
        atr_window=int(st.session_state["atr_window"]),
        atr_mult=float(st.session_state["atr_mult"]),
    )

def safe_run(df: pd.DataFrame, params: Dict[str, Any]):
    """F√∂rst f√∂rs√∂k df+**kwargs, annars bygg Params(**params) och k√∂r df+Params."""
    try:
        return RUN_BT(df, **params)
    except TypeError:
        pass
    if PARAMS_CLASS is not None:
        try:
            P = PARAMS_CLASS(**params)
            return RUN_BT(df, P)
        except Exception:
            pass
    return RUN_BT(df, params)

def show_result_block(title: str, res: Dict[str, Any]):
    st.subheader(title)
    sm = res.get("summary", {}) or {}
    c1,c2,c3,c4,c5 = st.columns(5)
    c1.metric("TotalReturn", f"{sm.get('TotalReturn',0)*100:.2f}%")
    c2.metric("Buy&Hold",   f"{sm.get('BuyHold',0)*100:.2f}%")
    c3.metric("MaxDD",      f"{sm.get('MaxDD',0)*100:.2f}%")
    c4.metric("CAGR",       f"{sm.get('CAGR',0)*100:.2f}%")
    c5.metric("Trades",     f"{int(sm.get('Trades',0))}")

    eq = res.get("equity")
    if isinstance(eq, pd.DataFrame) and not eq.empty:
        st.line_chart(eq.set_index("Date")["Equity"])
    tr = res.get("trades")
    if isinstance(tr, pd.DataFrame) and not tr.empty:
        keep = [c for c in ["EntryTime","EntryPrice","ExitTime","ExitPrice","PnL","reason"] if c in tr.columns]
        st.dataframe(tr[keep].tail(100), width='stretch')

# =========================
# SIDKONFIG & STATE-INIT
# =========================
st.set_page_config(page_title="Dalatrader ‚Äì Optimizer (Single + 3 profiler + Profiluppladdning)", layout="wide")
st.title("Optimizer")

STATE = st.session_state
STATE.setdefault("df", pd.DataFrame())
STATE.setdefault("ui", default_ui_params())
STATE.setdefault("ticker", "VOLV B")
STATE.setdefault("from_date", (dt.date.today() - dt.timedelta(days=365*5)).strftime("%Y-%m-%d"))
STATE.setdefault("to_date", dt.date.today().strftime("%Y-%m-%d"))
STATE.setdefault("loaded_profile_name", None)

# =========================
# =========================
# PROFIL ‚Äì V√§lj profil fr√•n server (ers√§tter uppladdning)
# =========================
from pathlib import Path
import json
import streamlit as st

with st.expander("üîé V√§lj optimeringsprofil (server)", expanded=True):
    _profiles_dir = Path("outputs/opt_results").resolve()
    _items = []
    for _fp in sorted(_profiles_dir.glob("*.json")):
        try:
            _data = json.loads(_fp.read_text(encoding="utf-8"))
            _profs = _data.get("profiles") or []
            _name = (_profs[0].get("name") or _profs[0].get("profile") or _fp.stem) if _profs else _fp.stem
            _tic  = (_profs[0].get("ticker") or "").strip() if _profs else ""
            _label = f"{_tic} ‚Äì {_name} [{_fp.name}]" if _tic else f"{_name} [{_fp.name}]"
            _items.append((_label, _fp))
        except Exception:
            _items.append((_fp.name, _fp))

    _labels = [lbl for lbl,_ in _items] or ["(inga profiler funna i outputs/opt_results)"]
    _choice = st.selectbox("Profil", _labels, key="server_profile_select")
    if _items and _choice in _labels:
        _fp = dict(_items)[_choice]
        st.caption(str(_fp))
        try:
            _data = json.loads(_fp.read_text(encoding="utf-8"))
            _prof = (_data.get("profiles") or [None])[0] or {}
            _t = (_prof.get("ticker") or "").strip()
            if _t:
                st.session_state["ticker"] = _t
            for _k, _v in (_prof.get("params") or {}).items():
                st.session_state[_k] = _v
            st.success("Profilen har applicerats p√• UI:t.")
        except Exception as _e:
            st.error(f"Kunde inte l√§sa {_fp.name}: {_e}")
# --- slut server-profiler ---

    st.markdown("**Ladda optimeringsprofil (.json) och applicera p√• UI**")


# --- Server-profiler ist√§llet f√∂r uppladdning ---
_profiles_dir = Path("outputs/opt_results").resolve()

def _discover_profiles_json(pdir: Path):
    items = []
    for fp in sorted(pdir.glob("*.json")):
        try:
            data = json.loads(fp.read_text(encoding="utf-8"))
            profs = data.get("profiles") or []
            if profs and isinstance(profs[0], dict):
                t = (profs[0].get("ticker") or "").strip()
                nm = (profs[0].get("name") or profs[0].get("profile") or fp.stem)
                lbl = f"{t} ‚Äì {nm} [{fp.name}]" if t else f"{nm} [{fp.name}]"
            else:
                lbl = fp.name
        except Exception:
            lbl = fp.name
        items.append((lbl, str(fp)))
    return items

_srv_profiles = _discover_profiles_json(_profiles_dir)
_srv_labels = [d for d,_ in _srv_profiles] or ["(inga profiler funna i outputs/opt_results)"]

sel_srv_prof = st.selectbox("V√§lj optimeringsprofil (fr√•n server)", _srv_labels, key="server_profile_select")

# Applicera vald profil p√• UI (ticker + params)
try:
    _map = dict(_srv_profiles)
    if sel_srv_prof in _map:
        _path = _map[sel_srv_prof]
        _data = json.loads(Path(_path).read_text(encoding="utf-8"))
        _prof = (_data.get("profiles") or [_data])[0]
        if isinstance(_prof, dict):
            _t = (_prof.get("ticker") or "").strip()
            if _t:
                st.session_state["ticker"] = _t
            _params = _prof.get("params") or {}
            for _k, _v in _params.items():
                st.session_state[_k] = _v
except Exception as _e:
    st.warning(f"Kunde inte l√§sa profil: {_e}")
# --- slut server-profiler ---
</div>", unsafe_allow_html=True)
if up is not None:
        try:
            payload = json.loads(up.read().decode("utf-8"))
            profs = payload.get("profiles") or []
            if not profs:
                st.error("Ingen 'profiles' i filen.")
            else:
                names = [p.get("name","(namnl√∂s)") for p in profs]
                idx = st.selectbox("V√§lj profil i filen", list(range(len(names))), format_func=lambda i: names[i])
                sel = profs[idx]
                st.write("F√∂rhandsgranskning:", {"name": sel.get("name"), "ticker": sel.get("ticker")})
                if st.button("Applicera profil p√• UI"):
                    # S√§tt STATE-v√§rden och trigga rerun *innan* widgets skapas
                    params = sel.get("params") or {}
                    STATE["ui"] = {**default_ui_params(), **params}
                    tkr = (sel.get("ticker") or STATE["ticker"])
                    STATE["ticker"] = str(tkr)
                    STATE["loaded_profile_name"] = sel.get("name")
                    st.success(f"Profil '{sel.get('name')}' applicerad. UI uppdateras‚Ä¶")
                    st.rerun()  # <-- uppdaterad: ers√§tter experimental_rerun()
        except Exception as e:
            st.error(f"Kunde inte l√§sa profil: {e}")

# =========================
# DATA & PERIOD
# =========================
cA, cB, cC = st.columns(3)
with cA:
    from pathlib import Path as _P
_tickers = _discover_tickers_from_profiles(_P('outputs/opt_results'))
ticker = st.selectbox('Ticker', options=_tickers or ['HM-B.ST'], key='ticker')
with cB:
    from_date = st.session_state.setdefault("from_date", STATE["from_date"])
from_date = st.text_input("Fr√•n (YYYY-MM-DD)", key="from_date")
with cC:
    to_date = st.session_state.setdefault("to_date", STATE["to_date"])
to_date = st.text_input("Till (YYYY-MM-DD)", key="to_date")

def fetch_df() -> pd.DataFrame:
    df = GET_OHLCV(ticker=ticker, start=from_date, end=to_date, source="borsdata")
    return normalize_df(df)

if st.button("H√§mta data", type="primary"):
    try:
        df = fetch_df()
        STATE["df"] = df
        st.success(f"L√§ste {len(df)} rader f√∂r {ticker}.")
        st.dataframe(df.tail(10), width='stretch')
    except Exception as e:
        st.error(f"Kunde inte ladda/st√§da data: {e}")

# =========================
# PARAMETER-WIDGETS (v√§rden tas fr√•n STATE['ui'])
# =========================
ui = STATE["ui"]

st.subheader("Parametrar")
c1,c2,c3 = st.columns(3)
with c1:
    st.checkbox("Anv√§nd EMA trend-gate", value=ui["use_trend_filter"], key="use_trend_filter")
    st.number_input("EMA-f√∂nster", 5, 300, int(ui["trend_ma_window"]), key="trend_ma_window")
    st.number_input("RSI-f√∂nster", 5, 50, int(ui["rsi_window"]), key="rsi_window")
    st.number_input("RSI min (k√∂p-kors upp)", 5.0, 45.0, float(ui["rsi_min"]), step=0.5, key="rsi_min")
    st.number_input("RSI max (s√§lj-kors ned)", 55.0, 90.0, float(ui["rsi_max"]), step=0.5, key="rsi_max")

with c2:
    st.number_input("Breakout lookback (0=av)", 0, 200, int(ui["breakout_lookback"]), key="breakout_lookback")
    st.number_input("Exit lookback (0=av)", 0, 200, int(ui["exit_lookback"]), key="exit_lookback")
    st.checkbox("MACD-filter (histogram > 0)", value=ui["use_macd_filter"], key="use_macd_filter")
    st.number_input("MACD fast", 3, 30, int(ui["macd_fast"]), key="macd_fast")
    st.number_input("MACD slow", 5, 60, int(ui["macd_slow"]), key="macd_slow")
    st.number_input("MACD signal", 2, 30, int(ui["macd_signal"]), key="macd_signal")

with c3:
    st.checkbox("Bollinger %B-filter", value=ui["use_bb_filter"], key="use_bb_filter")
    st.number_input("BB f√∂nster", 5, 60, int(ui["bb_window"]), key="bb_window")
    st.number_input("BB std", 1.0, 5.0, float(ui["bb_nstd"]), step=0.1, key="bb_nstd")
    st.number_input("%B ‚â§ (entry-tak)", 0.0, 1.0, float(ui["bb_min"]), step=0.05, key="bb_min")

st.subheader("Stop-loss")
cs1, cs2, cs3, cs4 = st.columns(4)
with cs1:
    st.checkbox("Aktivera stop-loss", value=ui["use_stop_loss"], key="use_stop_loss")
with cs2:
    st.selectbox("Stop-mod", options=["pct","atr"], index=0 if ui["stop_mode"]=="pct" else 1, key="stop_mode")
with cs3:
    st.number_input("Stop % (vid pct)", 0.01, 0.50, float(ui["stop_loss_pct"]), step=0.01, key="stop_loss_pct")
with cs4:
    st.number_input("ATR f√∂nster", 5, 100, int(ui["atr_window"]), key="atr_window")
    st.number_input("ATR multipel", 0.5, 5.0, float(ui["atr_mult"]), step=0.5, key="atr_mult")

# =========================
# K√∂rning ‚Äì ‚Äú1 eller 3‚Äù
# =========================
st.subheader("K√∂rning")
cm1, cm2, cm3 = st.columns(3)
mode = cm1.selectbox("L√§ge", options=["Single (1)", "Tre profiler (3)"], index=0, key="mode")
sims = int(cm2.number_input("Simuleringar per profil (N)", 1, 100_000, 2000, step=100, key="sims"))
seed = int(cm3.number_input("Slumpfr√∂", 0, 999_999, 42, step=1, key="seed"))
run_btn = st.button("K√∂r", type="primary")

def scorer_conservative(sm: Dict[str, Any]) -> float:
    return float(sm.get("TotalReturn",0)) - 0.8*abs(sm.get("MaxDD",0)) + 0.0005*sm.get("Trades",0)
def scorer_balanced(sm: Dict[str, Any]) -> float:
    return float(sm.get("TotalReturn",0)) - 0.5*abs(sm.get("MaxDD",0)) + 0.001*sm.get("Trades",0)
def scorer_aggressive(sm: Dict[str, Any]) -> float:
    return float(sm.get("TotalReturn",0)) - 0.2*abs(sm.get("MaxDD",0)) + 0.0015*sm.get("Trades",0)

def randomize_around(base: Dict[str, Any], r: random.Random) -> Dict[str, Any]:
    p = dict(base)
    p["rsi_window"] = r.randint(7, 30)
    p["rsi_min"] = r.uniform(10, 35)
    p["rsi_max"] = r.uniform(55, 85)
    if p["rsi_max"] - p["rsi_min"] < 10:
        p["rsi_max"] = p["rsi_min"] + 10

    p["use_trend_filter"] = r.random() < 0.7
    p["trend_ma_type"] = "EMA"
    p["trend_ma_window"] = r.randint(50, 180) if p["use_trend_filter"] else 0

    p["use_macd_filter"] = r.random() < 0.5
    if p["use_macd_filter"]:
        p["macd_fast"] = r.randint(8, 14)
        p["macd_slow"] = r.randint(20, 34)
        p["macd_signal"] = r.randint(6, 12)

    p["use_bb_filter"] = r.random() < 0.5
    if p["use_bb_filter"]:
        p["bb_window"] = r.randint(14, 28)
        p["bb_nstd"] = r.uniform(1.5, 2.5)
        p["bb_min"] = r.uniform(0.1, 0.5)

    p["use_stop_loss"] = r.random() < 0.5
    p["stop_mode"] = "atr" if r.random() < 0.5 else "pct"
    p["stop_loss_pct"] = r.uniform(0.03, 0.15)
    p["atr_window"] = r.randint(10, 20)
    p["atr_mult"] = r.uniform(1.5, 3.0)
    return p

def optimize(df: pd.DataFrame, base: Dict[str, Any], sims: int, seed: int, scorer, label_text: str) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    best_p = None; best_r = None; best_s = -1e18
    prog = st.progress(0.0, text=f"Optimerar ({label_text})‚Ä¶")
    r = random.Random(seed)
    for i in range(1, sims+1):
        p = randomize_around(base, r)
        res = safe_run(df, p)
        sm = res.get("summary", {}) or {}
        s = scorer(sm)
        if s > best_s:
            best_s, best_p, best_r = s, p, res
        if i % max(1, sims//100) == 0:
            prog.progress(i/sims, text=f"Optimerar ({label_text})‚Ä¶ {i}/{sims}")
    prog.empty()
    return best_p, best_r

if run_btn:
    df = STATE.get("df", pd.DataFrame())
    if df.empty:
        st.warning("H√§mta data f√∂rst.")
    else:
        base = make_params_from_state()
        if mode.startswith("Single"):
            # K√∂r exakt UI-parametrarna N g√•nger (samma tids√•tg√•ng som 3-profiler)
            prog = st.progress(0.0, text="Single k√∂rs‚Ä¶")
            last_res = None
            for i in range(1, sims+1):
                last_res = safe_run(df, base)
                if i % max(1, sims//100) == 0:
                    prog.progress(i/sims, text=f"Single k√∂rs‚Ä¶ {i}/{sims}")
            prog.empty()
            STATE["last_single"] = last_res
            STATE["last_params"] = base
            show_result_block("Single-run (resultat)", last_res)

            # Spara final
            if st.button(f"Spara som {ticker.replace(' ','_')}_final.json"):
                out_dir = Path(__file__).resolve().parents[1] / "outputs" / "opt_results"
                out_dir.mkdir(parents=True, exist_ok=True)
                out_path = out_dir / f"{ticker.replace(' ','_')}_final.json"
                payload = {
                    "profiles":[
                        {
                            "name": f"{ticker} ‚Äì final",
                            "ticker": ticker,
                            "params": base,
                            "metrics": last_res.get("summary", {}) or {}
                        }
                    ]
                }
                out_path.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")
                st.success(f"Sparat ‚Üí {out_path}")

        else:
            # Tre profiler
            p1, r1 = optimize(df, base, sims, seed+0, scorer_conservative, "Conservative")
            p2, r2 = optimize(df, base, sims, seed+1, scorer_balanced,     "Balanced")
            p3, r3 = optimize(df, base, sims, seed+2, scorer_aggressive,   "Aggressive")

            if r1: show_result_block("Conservative ‚Äì b√§sta", r1)
            if r2: show_result_block("Balanced ‚Äì b√§sta",     r2)
            if r3: show_result_block("Aggressive ‚Äì b√§sta",   r3)

            # Spara alla tre i en fil direkt
            if st.button(f"Spara 3-profiler som {ticker.replace(' ','_')}_best_backtrack.json"):
                out_dir = Path(__file__).resolve().parents[1] / "outputs" / "opt_results"
                out_dir.mkdir(parents=True, exist_ok=True)
                out_path = out_dir / f"{ticker.replace(' ','_')}_best_backtrack.json"
                payload = {"profiles":[]}
                for label, pr in [("conservative",(p1,r1)), ("balanced",(p2,r2)), ("aggressive",(p3,r3))]:
                    if pr[0] and pr[1]:
                        sm = pr[1].get("summary", {}) or {}
                        payload["profiles"].append({
                            "name": f"{ticker} ‚Äì {label}",
                            "ticker": ticker,
                            "params": pr[0],
                            "metrics": {
                                "TotalReturn": sm.get("TotalReturn",0.0),
                                "MaxDD": sm.get("MaxDD",0.0),
                                "SharpeD": sm.get("SharpeD",0.0),
                                "BuyHold": sm.get("BuyHold",0.0),
                                "CAGR": sm.get("CAGR",0.0),
                            }
                        })
                out_path.write_text(json.dumps(payload, ensure_ascii=False, indent=2), encoding="utf-8")
                st.success(f"Sparat ‚Üí {out_path}")






