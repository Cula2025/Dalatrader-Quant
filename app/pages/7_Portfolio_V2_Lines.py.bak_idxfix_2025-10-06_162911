from __future__ import annotations

import json
from pathlib import Path
from typing import List, Dict, Any, Iterable, Optional

import pandas as pd
import streamlit as st
import altair as alt

# Motor (fÃ¶r strategi-kurvor): fÃ¶rsÃ¶k backtracker, annars btwrap
try:
    from app.backtracker import run_backtest  # type: ignore
    MOTOR = "backtracker"
except Exception:
    from app import btwrap as W  # type: ignore
    run_backtest = W.run_backtest             # type: ignore
    MOTOR = "btwrap"

from app.equity_extract import extract_equity
from app.data_providers import get_ohlcv
from app.portfolio_math import (
    pick_first,
    equal_weight_rebalanced,
    equal_weight_buyhold,
)

INDEX_TICKER = "OMXS30GI"   # Stockholm GI (inkl utdelningar)

st.title("ðŸ“ˆ Portfolio V2 â€“ linjegraf (Strategi, Buy&Hold, Index)")
st.caption(f"Motor: {MOTOR}")

# ---------- HjÃ¤lpare ----------

def _to_datestr_first(idx) -> Optional[str]:
    """FÃ¶rsÃ¶k fÃ¥ YYYY-MM-DD frÃ¥n en index fÃ¶rsta vÃ¤rde, annars None."""
    try:
        v = idx[0]
        # pd.Timestamp
        if hasattr(v, "strftime"):
            return v.strftime("%Y-%m-%d")
        # datetime.date
        if hasattr(v, "isoformat"):
            return v.isoformat()
    except Exception:
        pass
    return None

def _read_params_for_ticker(ticker: str) -> Dict[str, Any]:
    """
    Hitta fÃ¶rsta profil med matchande ticker i profiles/*.json.
    Returnerar params eller {} om inget finns â€“ motorn fÃ¥r dÃ¥ defaulta.
    """
    prof_dir = Path("profiles")
    if not prof_dir.exists():
        return {}
    for jf in sorted(prof_dir.glob("*.json")):
        try:
            d = json.loads(jf.read_text(encoding="utf-8"))
            for pr in d.get("profiles", []):
                t = (pr.get("ticker") or pr.get("params", {}).get("ticker") or "").strip()
                if t.lower() == ticker.lower():
                    return dict(pr.get("params") or {})
        except Exception:
            continue
    return {}

def _strategy_equity_for_ticker(ticker: str) -> Optional[pd.Series]:
    """
    KÃ¶r backtest fÃ¶r tickern (med ev. profil-parametrar) och extrahera equity-serien.
    """
    params = _read_params_for_ticker(ticker)
    try:
        res = run_backtest(p={"ticker": ticker, "params": params})
        x = pick_first(res.get("equity"), res.get("summary"), res)
        s = extract_equity(x)
        if s is not None and len(s):
            return pd.to_numeric(s, errors="coerce").dropna()
    except Exception as e:
        st.warning(f"[Strategi] {ticker}: {type(e).__name__}: {e}")
    return None

def _bh_curve_for_tickers(tickers: Iterable[str], start: Optional[str]) -> Optional[pd.Series]:
    """
    Buy&Hold lika-vikt Ã¶ver givna tickers, normaliserad till 1.0.
    Vi hÃ¤mtar Close frÃ¥n BÃ¶rsdata, alignar gemensam period och tar medel av nivÃ¥erna.
    """
    cols: List[pd.Series] = []
    for t in tickers:
        try:
            df = get_ohlcv(ticker=t, start=start, end=None)[["Close"]].dropna()
            if len(df):
                s = df["Close"] / float(df["Close"].iloc[0])
                s.name = t
                cols.append(pd.to_numeric(s, errors="coerce").dropna())
        except Exception as e:
            st.warning(f"[BH] {t}: {type(e).__name__}: {e}")
    if not cols:
        return None
    return equal_weight_buyhold(cols)

def _index_curve(start: Optional[str]) -> Optional[pd.Series]:
    try:
        df = get_ohlcv(ticker=INDEX_TICKER, start=start, end=None)[["Close"]].dropna()
        if len(df):
            s = df["Close"] / float(df["Close"].iloc[0])
            s.name = INDEX_TICKER
            return pd.to_numeric(s, errors="coerce").dropna()
    except Exception as e:
        st.warning(f"[Index] {INDEX_TICKER}: {type(e).__name__}: {e}")
    return None

# ---------- UI: vÃ¤lj tickers ----------

default_universe = ["BOL", "EQT", "epi-a"]
tickers: List[str] = st.multiselect("VÃ¤lj tickers (max 10)", default_universe, default=default_universe, max_selections=10)

if not tickers:
    st.info("VÃ¤lj minst en ticker.")
    st.stop()

# ---------- 1) Strategi-portfÃ¶lj (EW rebalanced pÃ¥ strategiers equity) ----------

equities: List[pd.Series] = []
for t in tickers:
    s = _strategy_equity_for_ticker(t)
    if s is not None and len(s):
        equities.append(s)

if not equities:
    st.error("Kunde inte skapa nÃ¥gon strategikurva fÃ¶r de valda tickers.")
    st.stop()

port_reb = equal_weight_rebalanced(equities)               # rÃ¶d linje
start_str = _to_datestr_first(port_reb.index)              # anvÃ¤nds fÃ¶r index/BH
# Reservstart om index blev "steg" (RangeIndex)
if start_str is None:
    start_str = "2020-10-04"

# ---------- 2) Buy&Hold & Index (nivÃ¥serier) ----------

bh = _bh_curve_for_tickers(tickers, start=start_str)
idx = _index_curve(start=start_str)

# ---------- 3) Align och rita ----------

parts = [port_reb.rename("Portfolio")]
if bh is not None:
    parts.append(bh.rename("Buy&Hold"))
if idx is not None:
    parts.append(idx.rename(INDEX_TICKER))

df_plot = pd.concat(parts, axis=1, join="inner").dropna(how="all")

# Grafer med Altair (linjer, ingen area)
base = alt.Chart(df_plot.reset_index()).transform_fold(
    list(df_plot.columns), as_=["curve", "value"]
).mark_line().encode(
    x=alt.X(df_plot.index.name or "index", title="Tid / steg"),
    y=alt.Y("value:Q", title="Normaliserad nivÃ¥ (Ã—)"),
    color=alt.Color("curve:N", title="Kurva"),
    tooltip=["curve:N", "value:Q"]
).properties(height=420)

st.altair_chart(base, use_container_width=True)

# ---------- 4) Nyckeltal ----------

def _last(v: Optional[pd.Series]) -> Optional[float]:
    try:
        return float(v.iloc[-1])
    except Exception:
        return None

m = {
    "Portfolio_final": _last(port_reb),
    "BuyHold_final": _last(bh) if bh is not None else None,
    "OMXS30GI_final": _last(idx) if idx is not None else None,
}

c = st.columns(3)
c[0].metric("Portfolio", f"{m["Portfolio_final"]:.4f}Ã—" if m["Portfolio_final"] else "â€”")
c[1].metric("Buy&Hold", f"{m["BuyHold_final"]:.4f}Ã—" if m["BuyHold_final"] else "â€”")
c[2].metric("OMXS30GI", f"{m["OMXS30GI_final"]:.4f}Ã—" if m["OMXS30GI_final"] else "â€”")

start_label = _to_datestr_first(df_plot.index) or "â€”"
end_label   = _to_datestr_first([df_plot.index[-1]]) or "â€”"
st.caption(f"Start: {start_label}  â€¢  Slut: {end_label}")
