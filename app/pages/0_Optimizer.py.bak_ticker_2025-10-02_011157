# -*- coding: utf-8 -*-
from __future__ import annotations

import json, time, random, pathlib
from datetime import date, timedelta
from typing import Dict, Any, List, Tuple

import numpy as np
import pandas as pd
import streamlit as st


# === PREVIEW HOOK (capturar resultat-DataFrame) ===
try:
    import streamlit as _st_hook
    if not _st_hook.session_state.get("_OPT_PREVIEW_DF_HOOK_INSTALLED"):
        _st_orig_dataframe = _st_hook.dataframe
        def _st_dataframe_hook(obj, *a, **k):
            try:
                if hasattr(obj, "columns") and "SharpeD" in list(getattr(obj, "columns", [])):
                    # Spara undan DF f√∂r preview
                    _st_hook.session_state["_opt_preview_df"] = obj
            except Exception:
                pass
            return _st_orig_dataframe(obj, *a, **k)
        _st_hook.dataframe = _st_dataframe_hook
        _st_hook.session_state["_OPT_PREVIEW_DF_HOOK_INSTALLED"] = True
except Exception as _e_hook:
    print("[opt-preview] kunde inte installera dataframe-hook:", type(_e_hook).__name__, _e_hook)
# === /PREVIEW HOOK ===

# Branding (frivillig)
try:
    from app.branding import apply as brand
except Exception:
    def brand(*a, **k): pass

brand(page_title="Dala Trader ‚Äì Optimizer", page_icon="‚öôÔ∏è")
st.title("‚öôÔ∏è Optimizer")
st.caption("Optimerar tre strategier per ticker √∂ver valt intervall. H√§mtar OHLCV en g√•ng och k√∂r allt lokalt f√∂r fart.")

# ---- Imports f√∂r motorerna
from app.data_providers import get_ohlcv as GET_OHLCV
from backtest import run_backtest as RUN_BT

# ---- Hj√§lp
def ur(rng: random.Random, a: float, b: float) -> float:
    return a + (b - a) * rng.random()

def make_params(rng: random.Random) -> Dict[str, Any]:
    use_trend_filter = bool(rng.getrandbits(1))
    use_macd_filter  = bool(rng.getrandbits(1))
    use_bb_filter    = bool(rng.getrandbits(1))
    use_stop_loss    = bool(rng.getrandbits(1))
    use_atr_trailing = bool(rng.getrandbits(1))
    trend_ma_type    = rng.choice(["SMA","EMA"])
    return {
        "use_rsi_filter": True,
        "rsi_window": rng.randint(8, 32),
        "rsi_min": ur(rng, 5.0, 35.0),
        "rsi_max": ur(rng, 60.0, 85.0),

        "use_trend_filter": use_trend_filter,
        "trend_ma_type": trend_ma_type,
        "trend_ma_window": rng.randint(20, 200),

        "breakout_lookback": rng.randint(20, 120),
        "exit_lookback":     rng.randint(10, 60),

        "use_macd_filter": use_macd_filter,
        "macd_fast":   rng.randint(8, 16),
        "macd_slow":   rng.randint(18, 30),
        "macd_signal": rng.randint(8, 14),

        "use_bb_filter": use_bb_filter,
        "bb_window": rng.randint(15, 30),
        "bb_nstd":   ur(rng, 1.6, 2.4),
        "bb_min":    ur(rng, 0.0, 0.8),

        "use_stop_loss": use_stop_loss,
        "stop_mode": rng.choice(["pct","atr"]),
        "stop_loss_pct": ur(rng, 0.03, 0.20),

        "atr_window": rng.randint(10, 20),
        "atr_mult":   ur(rng, 1.2, 3.2),

        "use_atr_trailing": use_atr_trailing,
        "atr_trail_mult":   ur(rng, 1.2, 3.5),
    }

def score(metrics: Dict[str, Any]) -> float:
    tr = float(metrics.get("TotalReturn") or 0.0)
    sh = float(metrics.get("SharpeD") or 0.0)
    mdd = float(metrics.get("MaxDD") or 0.0)  # negativt tal
    return 2.0*tr + 1.0*sh + 0.5*(-mdd)

def five_year_window():
    end = date.today()
    start = end - timedelta(days=365*5 + 2)
    return start, end

@st.cache_data(show_spinner=False)
def load_ohlcv_cached(ticker: str, start: str, end: str) -> pd.DataFrame:
    df = GET_OHLCV(ticker=ticker, start=start, end=end)
    return df

def run_optimizer_ui(ticker: str, sims: int, seed: int, start: str, end: str):
    t0 = time.time()
    df = load_ohlcv_cached(ticker, start, end)
    if df is None or len(getattr(df, "index", [])) == 0:
        st.error("Tomt OHLCV f√∂r perioden.")
        return

    rng = random.Random(seed)
    best: List[Tuple[float, Dict[str,Any], Dict[str,Any]]] = []
    prog = st.progress(0)
    status = st.empty()

    for i in range(1, sims+1):
        p = make_params(rng)
        p["from_date"] = start
        p["to_date"]   = end
        try:
            res = RUN_BT(df, p)
            m = res.get("summary", {}) if isinstance(res, dict) else {}
            s = score(m)
            best.append((s, p, m))
            if len(best) > 16:
                best.sort(key=lambda x: x[0], reverse=True)
                best = best[:16]
        except Exception as e:
            # sv√§lj enstaka fel
            pass

        if (i % max(1, sims//100)) == 0 or i == sims:
            prog.progress(int(i*100/sims))
            status.text(f"K√∂r sim {i}/{sims} ‚Ä¶")

    best.sort(key=lambda x: x[0], reverse=True)
    top = best[:3]
    names = ["conservative", "balanced", "aggressive"]
    profiles = []
    for idx, (s, p, m) in enumerate(top):
        profiles.append({
            "name": f"{ticker} ‚Äì {names[idx]}",
            "ticker": ticker,
            "params": p,
            "metrics": m,
        })

    outdir = pathlib.Path("profiles")
    outdir.mkdir(parents=True, exist_ok=True)
    outfile = outdir / f"{ticker}.json"
    outfile.write_text(json.dumps({"profiles": profiles}, ensure_ascii=False, indent=2), encoding="utf-8")

    st.success(f"Klar. Sparade {len(profiles)} profiler ‚Üí {outfile}")
    # visa tabell
    rows = []
    for pr in profiles:
        m = pr.get("metrics", {})
        rows.append({
            "Name": pr.get("name",""),
            "TotalReturn": m.get("TotalReturn"),
            "SharpeD": m.get("SharpeD"),
            "MaxDD": m.get("MaxDD"),
            "Trades": m.get("Trades"),
            "FinalEquity": m.get("FinalEquity"),
            "BuyHold": m.get("BuyHold"),
        })
    st.dataframe(pd.DataFrame(rows))

    # applicera b√§sta till sessionen
    best_params = profiles[0]["params"] if profiles else None
    if best_params and st.button(f"‚úÖ Anv√§nd b√§sta f√∂r {ticker} i Backtest"):
        for k, v in best_params.items():
            st.session_state[k] = v
        st.session_state["ticker"] = ticker
        st.success("Applicerat till session. G√• till Backtest och k√∂r.")

# ---------- UI-kontroller ----------
col1, col2, col3, col4 = st.columns([1.1,1,1,1])
with col1:
    ticker = st.text_input("Ticker", value=st.session_state.get("ticker","GETI B")).strip()
with col2:
    sims = st.number_input("Antal simuleringar", min_value=100, max_value=100_000, value=1000, step=100)
with col3:
    seed = st.number_input("Seed", min_value=0, max_value=1_000_000, value=42, step=1)
with col4:
    last5 = st.checkbox("5 √•r bak√•t (auto)", value=True)

if last5:
    s, e = five_year_window()
    start, end = s.isoformat(), e.isoformat()
else:
    s = st.date_input("Start", value=five_year_window()[0])
    e = st.date_input("Slut", value=five_year_window()[1])
    start, end = s.isoformat(), e.isoformat()

st.markdown("---")
if st.button("üöÄ K√∂r optimering"):
    if not ticker:
        st.error("Ange en ticker.")
    else:
        run_optimizer_ui(ticker, int(sims), int(seed), start, end)
else:
    st.info("Tips: b√∂rja med 1 000‚Äì2 000 simuleringar. √ñka n√§r det ser rimligt ut.")

# --- OPT PREVIEW CHART BLOCK ---
import datetime as _dt
from app.btwrap import run_backtest as _RUNBT
from app.data_providers import get_ohlcv as _GET_OHLCV
import pandas as _pd

# === Datumv√§ljare (p√•verkar optimering och graf) ===
with st.sidebar.expander("Period", expanded=True):
    _today = _dt.date.today()
    _default_from = _today - _dt.timedelta(days=365*5)
    _from = st.date_input("Startdatum", value=_default_from, key="opt_from_date")
    _to   = st.date_input("Slutdatum",  value=_today,        key="opt_to_date")
    # Spegla till de nycklar som anv√§nds av motor/opt
    st.session_state["from_date"] = str(_from)
    st.session_state["to_date"]   = str(_to)

# === Hj√§lpare f√∂r att plocka params ur state ===
def _collect_params_from_state():
    s = st.session_state
    keys = [
        "from_date","to_date",
        "use_rsi_filter","rsi_window","rsi_min","rsi_max",
        "use_trend_filter","trend_ma_type","trend_ma_window",
        "breakout_lookback","exit_lookback",
        "use_macd_filter","macd_fast","macd_slow","macd_signal",
        "use_bb_filter","bb_window","bb_nstd","bb_min",
        "use_stop_loss","stop_mode","stop_loss_pct",
        "atr_window","atr_mult",
        "use_atr_trailing","atr_trail_mult",
    ]
    out = {}
    for k in keys:
        if k in s:
            out[k] = s[k]
    # Fallbacks
    if not out.get("from_date") and "opt_from_date" in s:
        out["from_date"] = str(s["opt_from_date"])
    if not out.get("to_date") and "opt_to_date" in s:
        out["to_date"] = str(s["opt_to_date"])
    return out

def _norm_equity_from_close(df):
    if df is None or not isinstance(df, _pd.DataFrame) or "Close" not in df.columns:
        return _pd.Series(dtype=float)
    s = _pd.to_numeric(df["Close"], errors="coerce").dropna()
    if s.empty:
        return s
    return s / s.iloc[0]

# === F√∂rhands-graf: Strategi vs Buy&Hold vs OMXS30 ===
st.markdown("### üìà F√∂rhandsgranskning (nuvarande inst√§llningar)")
_ticker = (st.session_state.get("ticker") or st.session_state.get("TICKER") or "").strip()
_index  = (st.session_state.get("index_ticker") or "OMXS30").strip()

col1, col2 = st.columns(2)
with col1:
    st.caption("Ticker: **{}**  |  Index: **{}**".format(_ticker or "‚Äì", _index))
with col2:
    st.caption("Period: **{} ‚Üí {}**".format(st.session_state.get("from_date","?"), st.session_state.get("to_date","?")))

if _ticker:
    try:
        _params = _collect_params_from_state()
        # Strategi
        _res = _RUNBT(_ticker, _params)
        _eq  = _res.get("equity")
        if isinstance(_eq, _pd.DataFrame) and {"Date","Equity"}.issubset(_eq.columns):
            strat = _eq.set_index("Date")["Equity"]
            strat = strat / strat.iloc[0]
        else:
            strat = _pd.Series(dtype=float)

        # Buy&Hold (ticker) och OMXS30
        _start = _params.get("from_date"); _end = _params.get("to_date")
        px_t = _GET_OHLCV(_ticker, start=_start, end=_end)
        px_i = _GET_OHLCV(_index,  start=_start, end=_end)
        bh   = _norm_equity_from_close(px_t).rename("Buy&Hold")
        idx  = _norm_equity_from_close(px_i).rename(_index)

        # Sammanslagning
        df_plot = _pd.concat(
            [strat.rename("Strategi"), bh, idx],
            axis=1
        ).dropna(how="all")
        if not df_plot.empty:
            st.line_chart(df_plot)
            # Snabb sammanfattning
            last = df_plot.iloc[-1]
            c1, c2, c3 = st.columns(3)
            if "Strategi" in last:
                c1.metric("Strategi slutv√§rde", "{:.2f}x".format(last["Strategi"]))
            else:
                c1.metric("Strategi slutv√§rde", "‚Äî")
            if "Buy&Hold" in last:
                c2.metric("Buy&Hold slutv√§rde", "{:.2f}x".format(last["Buy&Hold"]))
            else:
                c2.metric("Buy&Hold slutv√§rde", "‚Äî")
            if _index in last:
                c3.metric("{} slutv√§rde".format(_index), "{:.2f}x".format(last[_index]))
            else:
                c3.metric("{} slutv√§rde".format(_index), "‚Äî")
        else:
            st.info("Ingen data att plotta f√∂r vald period/inst√§llningar.")
    except Exception as _e:
        import traceback as _tb
        st.warning("F√∂rhandsgranskning misslyckades: {}: {}".format(type(_e).__name__, _e))
        st.code(_tb.format_exc())
else:
    st.info("Ange en ticker i Optimizern f√∂r att se grafen.")
# --- /OPT PREVIEW CHART BLOCK ---


# === _SHOW_OPTIMIZER_PREVIEW_BLOCK ===
import streamlit as _st
import pandas as _pd

def _opt_norm(_s):
    if _s is None or len(_s)==0: return _s
    s = _pd.Series(_s).astype(float)
    return s / s.iloc[0] if s.iloc[0] else s

def _opt_get_close(_ticker, _start, _end):
    try:
        from app.data import get_ohlcv as _GET
    except Exception:
        try:
            from app.sources import get_ohlcv as _GET
        except Exception:
            return _pd.Series(dtype="float64")
    try:
        df = _GET(_ticker, start=_start, end=_end)
    except TypeError:
        df = _GET(_ticker, _start, _end)
    except Exception:
        return _pd.Series(dtype="float64")
    if df is None or len(df)==0: return _pd.Series(dtype="float64")
    for c in ("Close","close","Adj Close","adjclose","adj_close","Price","price","last"):
        if c in df.columns:
            s = _pd.Series(df[c].values, index=_pd.to_datetime(df.index)).sort_index()
            return s
    try:
        s = _pd.Series(df.values, index=_pd.to_datetime(df.index)).sort_index()
        return s
    except Exception:
        return _pd.Series(dtype="float64")

def _opt_try_run_bt(_ticker, _params):
    try:
        from app.btwrap import run_backtest as _RUNBT
    except Exception as e:
        return None, None, e
    # variant 1
    try:
        out = _RUNBT({"ticker": _ticker, "params": _params})
        if isinstance(out, tuple) and len(out)>=2 and hasattr(out[1], "iloc"):
            return out[0], out[1], None
        if isinstance(out, dict) and isinstance(out.get("equity") or out.get("Equity"), _pd.DataFrame):
            return out.get("summary") or out, (out.get("equity") or out.get("Equity")), None
    except Exception as e:
        last = e
    else:
        last = None
    # variant 2
    try:
        out = _RUNBT(_ticker, _params)
        if isinstance(out, tuple) and len(out)>=2 and hasattr(out[1], "iloc"):
            return out[0], out[1], None
        if isinstance(out, dict) and isinstance(out.get("equity") or out.get("Equity"), _pd.DataFrame):
            return out.get("summary") or out, (out.get("equity") or out.get("Equity")), None
    except Exception as e:
        last = e
    return None, None, last

def _show_optimizer_preview():
    df = _st.session_state.get("_opt_preview_df")
    if df is None or len(df)==0:
        return  # inget att visa √§n
    ticker = (_st.session_state.get("ticker") or "").strip()
    start  = str(_st.session_state.get("from_date") or _st.session_state.get("start") or "")
    end    = str(_st.session_state.get("to_date")   or _st.session_state.get("end")   or "")
    if not (ticker and start and end):
        return

    # Sortera b√§sta rad
    dfx = df.copy()
    for c in ("SharpeD","TotalReturn"):
        if c not in dfx.columns:
            dfx[c] = _pd.NA
    dfx = dfx.sort_values(by=["SharpeD","TotalReturn"], ascending=[False, False])
    row = dfx.iloc[0]

    # Params (fr√•n 'params'-kolumn om den finns)
    params = {}
    if "params" in row and isinstance(row["params"], dict):
        params = dict(row["params"])
    else:
        for k in ["use_rsi_filter","rsi_window","rsi_min","rsi_max","use_trend_filter","trend_ma_type","trend_ma_window",
                  "breakout_lookback","exit_lookback","use_macd_filter","macd_fast","macd_slow","macd_signal",
                  "use_bb_filter","bb_window","bb_nstd","bb_min","use_stop_loss","stop_mode","stop_loss_pct",
                  "atr_window","atr_mult","use_atr_trailing","atr_trail_mult"]:
            if k in dfx.columns and _pd.notna(row.get(k)):
                params[k] = row[k]

    # K√∂r backtest ‚Üí equity
    summary, eq, err = _opt_try_run_bt(ticker, params)
    _st.markdown("### F√∂rhandsgranskning")
    if err is not None:
        _st.warning(f"F√∂rhands-backtest misslyckades: {type(err).__name__}: {err}")
        return
    if eq is None or "Equity" not in eq.columns:
        _st.info("Ingen equity-serie tillg√§nglig f√∂r f√∂rhandsgranskning.")
        return

    strat = _opt_norm(eq["Equity"].rename("Strategi"))
    bh = _opt_norm(_opt_get_close(ticker, start, end)).rename("Buy&Hold")
    idx = _opt_norm(_opt_get_close("OMXS30", start, end)).rename("OMXS30 (index)")

    dd = _pd.concat([strat, bh, idx], axis=1).dropna(how="all").sort_index()
    if dd.empty:
        _st.info("Saknar prisdata f√∂r att rita graf.")
        return

    _st.caption(f"Ticker: {ticker} | Index: OMXS30 ‚Äî Period: {start} ‚Üí {end}")
    _st.line_chart(dd)

# Rendera preview allra sist (efter att DataFrame har visats)
try:
    _show_optimizer_preview()
except Exception as _e_prev:
    print("[opt-preview] preview-fel:", type(_e_prev).__name__, _e_prev)
# === /_SHOW_OPTIMIZER_PREVIEW_BLOCK ===


# --- OPT_PREVIEW_CHART ---
# F√∂rhandsgranskning: Strategi vs Buy&Hold vs OMX30
# - Hittar ticker automatiskt (session ‚Üí profiler)
# - K√∂r backtest p√• b√§sta profilen i profiles/<TICKER>.json
# - Ritar j√§mf√∂relse mot Buy&Hold och OMX30 (yfinance om m√∂jligt)

import pandas as pd
import streamlit as st
from pathlib import Path as _Path

# safe-imports
try:
    from app.btwrap import run_backtest as _RUNBT  # v√•r wrapper runt backtest
except Exception as _e:
    _RUNBT = None
    st.warning("[Preview] Kunde inte importera run_backtest: %s: %s" % (type(_e).__name__, _e))

def _opt_guess_ticker() -> str:
    # 1) f√∂rs√∂k fr√•n session med vanliga nycklar
    for k in ("ticker","opt_ticker","srv_ticker","symbol","ticker_input"):
        v = st.session_state.get(k)
        if isinstance(v, str) and v.strip():
            return v.strip()

    # 2) f√∂rs√∂k via senaste profilfilen i profiles/
    base = _Path("/srv/trader/app/profiles") if _Path("/srv/trader/app/profiles").exists() else _Path("profiles")
    try:
        files = sorted(base.glob("*.json"), key=lambda x: x.stat().st_mtime, reverse=True)
        if files:
            # l√§s ticker ur filen om den finns
            import json
            with open(files[0], "r", encoding="utf-8") as f:
                data = json.load(f)
            profs = data.get("profiles", [])
            if profs:
                t = (profs[0].get("ticker") or "").strip()
                if t:
                    return t
            # annars ta filnamnets stem
            return files[0].stem
    except Exception:
        pass
    return ""

def _preview_find_profiles_file(ticker: str | None) -> _Path | None:
    base = _Path("/srv/trader/app/profiles") if _Path("/srv/trader/app/profiles").exists() else _Path("profiles")
    if ticker:
        cand = base / f"{ticker}.json"
        if cand.exists():
            return cand
    # fallback: senaste *.json
    files = sorted(base.glob("*.json"), key=lambda x: x.stat().st_mtime, reverse=True)
    return files[0] if files else None

def _preview_load_best_params(prof_path: _Path):
    try:
        import json
        with open(prof_path, "r", encoding="utf-8") as f:
            data = json.load(f)
        profiles = data.get("profiles", [])
        if not profiles:
            return None
        # anta att index 0 = b√§st
        return profiles[0].get("params") or {}
    except Exception as e:
        st.warning("[Preview] Kunde inte l√§sa %s: %s: %s" % (prof_path.name, type(e).__name__, e))
        return None

def _preview_load_index_series(sym: str, start: str | None, end: str | None, label: str):
    try:
        import yfinance as yf
    except Exception:
        return None
    try:
        df = yf.download(sym, start=start, end=end, progress=False)
        if not isinstance(df, pd.DataFrame) or df.empty or "Close" not in df:
            return None
        s = (df["Close"] / df["Close"].iloc[0]).rename(label)
        s.index = pd.to_datetime(s.index)
        return s
    except Exception:
        return None

def _preview_plot():
    ticker = _opt_guess_ticker()
    fd = st.session_state.get("from_date") or None
    td = st.session_state.get("to_date") or None

    st.subheader("üìà F√∂rhandsgranskning (b√§sta strategi vs Buy&Hold vs OMX30)")
    if not ticker:
        st.info("Ange en ticker i Optimizern eller spara en profil i `profiles/` f√∂r att se grafen.")
        return
    if _RUNBT is None:
        st.info("Backtest-funktion saknas, kan inte rita strategiserien.")
        return

    prof_path = _preview_find_profiles_file(ticker)
    if not prof_path:
        st.info("Hittar ingen profilfil. K√∂r f√∂rst optimering s√• att profiler sparas i `profiles/`.")
        return

    best_params = _preview_load_best_params(prof_path)
    if not best_params:
        st.info("Inga parametrar hittades i %s." % prof_path.name)
        return

    # Strategi (backtest)
    try:
        bt_df = _RUNBT(ticker=ticker, params=best_params, start=fd, end=td)
        if not isinstance(bt_df, pd.DataFrame) or "Equity" not in bt_df:
            st.info("Backtest gav inget giltigt equity-resultat.")
            return
        eq_strat = bt_df["Equity"].copy().rename("Strategi")
        eq_strat.index = pd.to_datetime(eq_strat.index)
        if float(eq_strat.iloc[0]) != 0.0:
            eq_strat = eq_strat / float(eq_strat.iloc[0])
    except Exception as e:
        st.warning("[Preview] Backtest fel: %s: %s" % (type(e).__name__, e))
        return

    # Buy&Hold (om m√∂jligt)
    eq_bh = _preview_load_index_series(ticker, fd, td, "Buy&Hold")

    # OMX30 (index)
    eq_idx = (
        _preview_load_index_series("^OMX", fd, td, "OMX30")
        or _preview_load_index_series("^OMXS30", fd, td, "OMXS30")
        or _preview_load_index_series("^OMX30", fd, td, "OMX30")
    )

    parts = [x for x in (eq_strat, eq_bh, eq_idx) if isinstance(x, pd.Series)]
    if not parts:
        st.info("Kunde inte sammanst√§lla serier f√∂r f√∂rhandsgranskning.")
        return
    df_plot = pd.concat(parts, axis=1)

    # Rita (plotly om m√∂jligt)
    try:
        import plotly.express as px
        fig = px.line(df_plot, x=df_plot.index, y=df_plot.columns,
                      title=f"{ticker} ‚Äì Strategi vs Buy&Hold vs OMX30")
        st.plotly_chart(fig, width='stretch')
    except Exception:
        st.line_chart(df_plot)

_preview_plot()
# --- /OPT_PREVIEW_CHART ---


